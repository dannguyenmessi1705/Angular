# Service trong Angular
## 1. Giới thiệu
`Service` trong Angular là một đối tượng dùng để chia sẻ dữ liệu và logic giữa các thành phần (components) trong ứng dụng. Service giúp tách biệt logic nghiệp vụ ra khỏi các thành phần, từ đó làm cho mã nguồn dễ bảo trì và kiểm thử hơn.

## 2. Tạo Service
Để tạo một service trong Angular, bạn có thể sử dụng Angular CLI với lệnh sau:
```bash
ng generate service <ten-service>
```
Hoặc viết tay một file service mới trong thư mục `src/app`.

```typescript
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class TenService {

  constructor() { }
}
```

- `Injectable`: Đánh dấu class là một service và cho phép Angular tiêm nó vào các thành phần khác.
- `providedIn`: Xác định phạm vi cung cấp của service. Ở đây, service được cung cấp ở cấp root, có nghĩa là nó sẽ tồn tại trong suốt vòng đời của ứng dụng.

## 3. Sử dụng Service
Để sử dụng service trong một component, bạn cần tiêm service đó vào constructor của component.

Có các cách để tiêm service vào component:

1. **Tiêm qua constructor**: Đây là cách phổ biến nhất. Bạn chỉ cần thêm service vào constructor của component như đã làm ở trên.
2. **Tiêm qua phương thức**: Bạn có thể tạo một phương thức trong component và tiêm service vào phương thức đó.
3. **Tiêm qua thuộc tính**: Bạn có thể tiêm service vào một thuộc tính của component.
4. **Tiêm qua inject**: Bạn có thể sử dụng `inject` để lấy instance của service.


```typescript
import { Component, OnInit } from '@angular/core';
import { TenService } from '../ten.service';

@Component({
  selector: 'app-ten',
  templateUrl: './ten.component.html',
  styleUrls: ['./ten.component.css']
})
export class TenComponent implements OnInit {

  constructor(private tenService: TenService) { } // Tiêm service vào component thông qua constructor

// Tiêm service vào component thông qua phương thức
//   someMethod() {
//     this.tenService = new TenService();
//   }

// Tiêm service vào component thông qua thuộc tính
//   someProperty: TenService;

//   constructor() {
//     this.someProperty = new TenService();
//   }

// Tiêm service vào component thông qua inject
    // tenService = inject(TenService);

}
```

> Ngoài ra, bạn cũng có thể sử dụng `service` trong component mà không cần khai báo annotation `@Injectable` bằng cách thêm `providers` vào decorator `@Component`.

```typescript
import { Component } from '@angular/core';
import { TenService } from '../ten.service';

@Component({
  selector: 'app-ten',
  templateUrl: './ten.component.html',
  styleUrls: ['./ten.component.css'],
  providers: [TenService]
})
export class TenComponent {

  constructor(private tenService: TenService) { }

}
```

> Để tiêm `service` vào một `service` khác thì cách làm tương tự như tiêm vào component. Bạn chỉ cần tiêm service cần thiết vào constructor của service đó.

```typescript
import { Injectable } from '@angular/core';
import { TenService } from './ten.service';

@Injectable({
  providedIn: 'root'
})
export class AnotherService {

  constructor(private tenService: TenService) { }

  // Hoặc
  // tenService = inject(TenService);

}
```

## 4. Sử dụng `provider` inject các thành phần không phải là service (Custom DI Token)
Để sử dụng `provider` inject các thành phần không phải là service, bạn có thể tạo một `InjectionToken` và sử dụng nó trong `providers` của component hoặc module.

```typescript
import { InjectionToken } from '@angular/core';

export const CUSTOM_TOKEN = new InjectionToken<string>('CustomToken');

// Sau đó, bạn có thể inject `CUSTOM_TOKEN` vào bất kỳ component hoặc service nào.

```

> Ví dụ `module` mode.
```ts
@NgModule({
  providers: [
    { provide: CUSTOM_TOKEN, useValue: 'Giá trị tùy chỉnh' }
  ]
})
export class AppModule { }
```

```typescript
import { Component, Inject } from '@angular/core';
import { CUSTOM_TOKEN } from './app.module';

@Component({
  selector: 'app-ten',
  templateUrl: './ten.component.html',
  styleUrls: ['./ten.component.css']
})
export class TenComponent {

  constructor(@Inject(CUSTOM_TOKEN) private customValue: string) {
    console.log(this.customValue);
  }

}
```
> Ví dụ `standalone` component.
```typescript
import { Component, Inject } from '@angular/core';
import { CUSTOM_TOKEN } from './app.module';

@Component({
  selector: 'app-ten',
  templateUrl: './ten.component.html',
  styleUrls: ['./ten.component.css'],
  standalone: true,
  providers: [
    { provide: CUSTOM_TOKEN, useValue: 'Giá trị tùy chỉnh' }
  ]
})
export class TenComponent {

  constructor(@Inject(CUSTOM_TOKEN) private customValue: string) {
    console.log(this.customValue);
  }

}
```

Ngoài `useValue`, bạn cũng có thể sử dụng `useClass`, `useFactory` hoặc `useExisting` để cung cấp giá trị cho `InjectionToken`.
    - `useClass`: Sử dụng một class để cung cấp giá trị cho token.
    - `useFactory`: Sử dụng một hàm factory để cung cấp giá trị cho token.
    - `useExisting`: Sử dụng một token khác đã được định nghĩa trước đó.

> Ví dụ sử dụng `useFactory`

```typescript
import { InjectionToken } from '@angular/core';

export const CUSTOM_TOKEN = new InjectionToken<Date>('CustomToken');

export const CUSTOM_DATE_PROVIDER = {
  provide: CUSTOM_TOKEN,
  useFactory: () => new Date()
};
```

```typescript
import { Component, Inject } from '@angular/core';
import { CUSTOM_TOKEN } from './app.module';

@Component({
  selector: 'app-ten',
  templateUrl: './ten.component.html',
  styleUrls: ['./ten.component.css'],
  providers: [CUSTOM_DATE_PROVIDER]
})
export class TenComponent {

  constructor(@Inject(CUSTOM_TOKEN) private customValue: Date) {
    console.log(this.customValue);
  }

}
```

## 5. Phạm vi cung cấp (`providedIn`) và vòng đời service
- `providedIn: 'root'`: Service duy nhất cho toàn bộ ứng dụng (singleton). Thích hợp cho state chung như Auth, Settings.
- `providedIn: 'any'`: Tạo instance mới cho mỗi lazy module hoặc standalone component được load. Giúp cô lập state theo feature.
- `providedIn: 'platform'`: Chia sẻ cho mọi Angular app chạy trên cùng trang (ít dùng, nhưng hữu ích khi nhúng micro-frontend).
- `providedIn` nhận cả một `type` (module, component) – Angular sẽ tree-shake các service không dùng giúp bundle nhỏ gọn hơn.
- Ngoài ra bạn có thể cung cấp service trực tiếp tại `providers` của component/route. Khi đó mỗi lần route được kích hoạt sẽ tạo instance mới (phù hợp cho màn hình wizard nhiều bước).

## 6. Các pattern thường gặp với service
- **Service truy cập API**: Bao bọc `HttpClient` và trả về `Observable` hoặc `Signal`. Thêm `retry`, `catchError` ngay trong service để component mỏng nhất có thể.
```ts
@Injectable({ providedIn: 'root' })
export class ProjectsApi {
  private readonly http = inject(HttpClient);

  list() {
    return this.http.get<Project[]>('/api/projects').pipe(
      retry(1),
      catchError(err => throwError(() => new Error(err.message ?? 'Load thất bại')))
    );
  }
}
```
- **Service quản lý state (facade/store)**: Gom logic thay đổi state và expose các `readonly` signal hoặc observable.
```ts
@Injectable({ providedIn: 'root' })
export class ProjectsStore {
  private readonly api = inject(ProjectsApi);
  private readonly _projects = signal<Project[]>([]);

  readonly projects = this._projects.asReadonly();
  readonly total = computed(() => this._projects().length);

  load() {
    return this.api.list().subscribe({
      next: data => this._projects.set(data)
    });
  }
}
```
- **Service tiện ích**: Các hàm thuần (formatter, logger) không cần state vẫn nên đặt trong service để dễ thay thế bằng mock khi test. Nếu muốn service không bị tree-shake hãy nhớ sử dụng ở nơi cần thiết hoặc export rõ ràng.

## 7. Kiểm thử service và phụ thuộc
- Với service đơn giản, chỉ cần khởi tạo trực tiếp `const service = new MyService();`.
- Khi service phụ thuộc vào Angular DI (HttpClient, Router, …), dùng `TestBed.configureTestingModule` để cung cấp mock. Ví dụ:
```ts
describe('ProjectsStore', () => {
  let store: ProjectsStore;
  let api: jasmine.SpyObj<ProjectsApi>;

  beforeEach(() => {
    TestBed.configureTestingModule({
      providers: [
        ProjectsStore,
        {
          provide: ProjectsApi,
          useValue: jasmine.createSpyObj('ProjectsApi', ['list']),
        },
      ],
    });

    store = TestBed.inject(ProjectsStore);
    api = TestBed.inject(ProjectsApi) as jasmine.SpyObj<ProjectsApi>;
  });

  it('load dữ liệu thành công', () => {
    api.list.and.returnValue(of([{ id: '1', name: 'Demo' }]));
    store.load();
    expect(store.projects().length).toBe(1);
  });
});
```
- Khi service tạo subscription, hãy trả về `Subscription` từ phương thức `load()` để component gọi `unsubscribe`, hoặc gắn `takeUntilDestroyed()` ngay trong service nếu bạn biết chắc service sẽ sống theo vòng đời component.
