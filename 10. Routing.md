# Routing
## 1. Giới thiệu
- Routing trong Angular cho phép điều hướng giữa các thành phần khác nhau trong ứng dụng. Nó giúp quản lý các URL và hiển thị các thành phần tương ứng dựa trên URL hiện tại.
- Angular Router là một module mạnh mẽ cho phép bạn định nghĩa các tuyến đường (routes) trong ứng dụng của mình.
- Trong Angular nhờ routing có thể xây dựng các ứng dụng một trang (Single Page Applications - SPA) và ứng dụng đa trang (Multi-Page Applications - MPA).

## 2. Cấu hình Routing cơ bản

Để cấu hình routing trong Angular, bạn cần định nghĩa các tuyến đường (routes) trong ứng dụng của mình. Các tuyến đường này sẽ ánh xạ các URL đến các thành phần tương ứng.

### 2.1. Định nghĩa Routes

Trong Angular, bạn có thể định nghĩa các routes trong một file riêng biệt, thường là `app.routes.ts`. Dưới đây là một ví dụ về cách định nghĩa các routes:

```typescript
import { Routes } from "@angular/router";
import { TaskComponent } from "./tasks/task/task.component";
import { NoTaskComponent } from "./tasks/no-task/no-task.component";

export const routes: Routes = [
  {
    path: "", // <domain>/
    component: NoTaskComponent,
  },
  {
    path: "tasks", // <domain>/tasks
    component: TaskComponent,
  },
  {
    path: "**",
    component: ErrorComponent
  }
];
```
> Nên định nghĩa một component ErrorComponent để hiển thị thông báo lỗi khi không tìm thấy route ở cuối cùng (mức ưu tiên thấp nhất)

### 2.2. Cấu hình Config cho `main.ts`

Sau khi định nghĩa các routes, bạn cần cấu hình bật Router rồi import vào trong `providers` bằng cách tạo `app.config.ts`:

```typescript
import { provideRouter } from "@angular/router";
import { ApplicationConfig } from "@angular/core";
import { routes } from "./app.routes";

export const appConfig: ApplicationConfig = {
  providers: [
    provideRouter(routes) // Cấu hình Router, cho phép điều hướng giữa các thành phần
  ],
};
```
Sau đó thêm cấu hình vào trong `main.ts`:

```typescript
import { bootstrapApplication } from "@angular/platform-browser";

import { AppComponent } from "./app/app.component";
import { appConfig } from "./app/app.config";

bootstrapApplication(AppComponent, appConfig).catch((err) =>
  console.error(err)
);

```

### 2.3. Sử dụng `<router-outlet>`
Router Outlet là một chỉ thị trong Angular cho phép bạn hiển thị các thành phần tương ứng với các tuyến đường đã định nghĩa. Để sử dụng Router Outlet, bạn cần thêm nó vào trong template của thành phần cha.

Ví dụ: `app.component.html`

```html
<app-header />

<main>
  <app-users />

  <div>
    <router-outlet />
  </div>
</main>

```

Sau đó import `RouterOutlet` vào trong `component` đang sử dụng
```ts
import { Component } from '@angular/core';

import { HeaderComponent } from './header/header.component';
import { UsersComponent } from './users/users.component';
import { RouterOutlet } from '@angular/router';

@Component({
  selector: 'app-root',
  standalone: true,
  templateUrl: './app.component.html',
  styleUrl: './app.component.css',
  imports: [HeaderComponent, UsersComponent, RouterOutlet],
})
export class AppComponent {}
```

> Khi người dùng điều hướng đến một tuyến đường cụ thể, Angular sẽ tự động thay thế nội dung của Router Outlet bằng thành phần tương ứng với tuyến đường đó. (Chỉ hiển thị một thành phần `Router Outlet` tại một thời điểm, còn tất cả các thẻ khác không phải `Router Outlet` vẫn sẽ được giữ nguyên).


## 3. Routing nâng cao
### 3.1. Điều hướng giữa các thành phần
Thông thường thẻ `a` sẽ được sử dụng để điều hướng giữa các thành phần trong web bằng thuộc tính `href`. Tuy nhiên nó sẽ làm web bị tải lại toàn bộ trang và sẽ mất đi trạng thái của ứng dụng. Vì thế trong Angular, bạn có thể sử dụng thuộc tính `routerLink` để chỉ định tuyến đường mà bạn muốn điều hướng đến mà không làm mất đi trạng thái của ứng dụng.
Ví dụ:

```html
<a routerLink="/tasks">Đi đến trang Tasks</a>
```

Sau đó, trong `component` của template này, ta import thêm `RouterLink` vào trong `component` đang sử dụng
```ts
import { Component } from '@angular/core';

import { HeaderComponent } from './header/header.component';
import { UsersComponent } from './users/users.component';
import { RouterLink } from '@angular/router';

@Component({
  selector: 'app-root',
  standalone: true,
  templateUrl: './app.component.html',
  styleUrl: './app.component.css',
  imports: [HeaderComponent, UsersComponent, RouterLink],
})
export class AppComponent {}

```

> Khi người dùng nhấp vào liên kết này, Angular sẽ điều hướng đến tuyến đường `/tasks` và hiển thị thành phần tương ứng với tuyến đường đó trong Router Outlet.

Ngoài ra Angular còn cung cấp thêm class styles cho các đường link được active nhờ sử dụng `routerLinkActive`.
```html
<a routerLink="/tasks" routerLinkActive="selected">Đi đến trang Tasks</a>
```
Sau đó thêm `RouterLinkActive` vào phần `imports` của `Component`.

> Có thể truyền vào `routerLink` một mảng các tham số, sau đó Angular sẽ tự động ghép chúng lại thành một đường dẫn ngăn cách bằng dấu `/`. (Ví dụ: `[routerLink]="['/tasks', task().id]"` sẽ tạo thành đường dẫn `/tasks/1` nếu `task().id` là `1`) hoặc `[routerLink]="'/tasks/' + task().id"` hoặc `routerLink="{{'/tasks/' + task().id}}"`.

Sử dụng **điều hướng lập trình (Programmatic Navigation)** cho phép bạn điều hướng đến các route một cách linh hoạt hơn khi đang xử lý logic trong component. Để làm điều này chúng ta cần inject `Router` vào trong component.
```ts
import { Component } from '@angular/core';
import { Router } from '@angular/router';

@Component({
  selector: 'app-example',
  templateUrl: './example.component.html',
  styleUrls: ['./example.component.css']
})
export class ExampleComponent {
  constructor(private router: Router) {}

  navigateToTasks() {
    this.router.navigate(['/tasks'], {
      queryParams: { userId: 123 }, // Thêm tham số truy vấn (/tasks?userId=123)
      replaceUrl: true // Thay thế URL hiện tại (không thêm vào lịch sử, và người dùng không thể quay lại trang trước đó)
    });
  }
}

```

### 3.2. Điều hướng tới các route động (Dynamic Routing)
Dynamic Routing cho phép bạn định nghĩa các tuyến đường với các tham số động. Điều này rất hữu ích khi bạn cần hiển thị nội dung khác nhau dựa trên các tham số trong URL.

Ví dụ: Giả sử bạn có một trang chi tiết cho từng tác vụ và bạn muốn điều hướng đến trang đó với ID của tác vụ. Bạn có thể định nghĩa một tuyến đường như sau:

```ts
const routes: Routes = [
  {
    path: 'tasks/:id',
    component: TaskDetailComponent
  }
];
```
> `:id` là một tham số động (paramete của đường dẫn)

Trong ví dụ này, `:id` là một tham số động. Khi người dùng điều hướng đến `/tasks/1`, Angular sẽ hiển thị `TaskDetailComponent` và bạn có thể truy cập ID của tác vụ thông qua `ActivatedRoute`.

#### 3.2.1. Truy cập tham số động trong component với Input

Để truy cập tham số động trong component, bạn có thể sử dụng `withComponentInputBinding()` làm đối số thứ hai của `provideRouter` trong list provider của bạn. `withComponentInputBinding()` cho phép bạn ánh xạ các tham số route thành các thuộc tính đầu vào của component (bao gồm `dynamicRoute`, `data`, `title`, `resolver`,..). Ví dụ

```ts
import { provideRouter, withComponentInputBinding } from "@angular/router";
import { ApplicationConfig } from "@angular/core";
import { routes } from "./app.routes";

export const appConfig: ApplicationConfig = {
  providers: [provideRouter(routes, withComponentInputBinding())],
};
```

Sau đó sử dụng `input` trong component của bạn để nhận giá trị của tham số động. Với điều kiện là biến đặt tên giống với tên tham số trong route và phải thêm điều kiện là bắt buộc `input.required`.

```ts
import {
  Component,
  computed,
  DestroyRef,
  inject,
  Input,
  input,
  OnInit,
} from "@angular/core";
import { UsersService } from "../users.service";
import { ActivatedRoute } from "@angular/router";

@Component({
  selector: "app-user-tasks",
  standalone: true,
  templateUrl: "./user-tasks.component.html",
  styleUrl: "./user-tasks.component.css",
})
export class UserTasksComponent implements OnInit {
  private userService = inject(UsersService);
  userId = input.required<string>();
  username = computed(
    () => this.userService.users.find((u) => u.id === this.userId()?.name
  );
}

```

#### 3.2.2. Truy cập tham số động bằng Observable

Để truy cập tham số động bằng Observable, bạn có thể sử dụng `ActivatedRoute` để lấy thông tin về route hiện tại. Và không cần phải thêm tham số thứ 2 là `withComponentInputBinding()` vào `provideRouter`.

```ts
import {
  Component,
  computed,
  DestroyRef,
  inject,
  Input,
  input,
  OnInit,
} from "@angular/core";
import { UsersService } from "../users.service";
import { ActivatedRoute } from "@angular/router";

@Component({
  selector: "app-user-tasks",
  standalone: true,
  templateUrl: "./user-tasks.component.html",
  styleUrl: "./user-tasks.component.css",
})
export class UserTasksComponent implements OnInit {
  private userService = inject(UsersService);

  username: string = "";
  private destroyRef = inject(DestroyRef);
  private activatedRoute = inject(ActivatedRoute);

  ngOnInit(): void {
    console.log(this.activatedRoute);
    const sub = this.activatedRoute.params.subscribe({
      next: (params) => {
        this.username =
          this.userService.users.find((u) => u.id === params["userId"])?.name ??
          "";
      },
    });
    this.destroyRef.onDestroy(() => sub.unsubscribe());
  }
}

```

### 3.3. Nested Routes (Child Routes)
Nested Routes (Child Routes) cho phép bạn định nghĩa các tuyến đường con bên trong một tuyến đường cha. Điều này rất hữu ích khi bạn muốn tổ chức các thành phần của mình theo cấu trúc phân cấp.

Chỉ cần thêm thuộc tính `children` vào đối tượng route cha và định nghĩa các tuyến đường con bên trong mảng `children` như cách định nghĩa các tuyến đường thông thường route cha.

VD: Tạo 1 route như sau `/users/:userId/tasks` để hiển thị các nhiệm vụ của người dùng cụ thể.

```ts
import { Routes } from "@angular/router";
import { UserTasksComponent } from "./users/user-tasks/user-tasks.component";

const routes: Routes = [
  {
    path: "users/:userId",
    component: UserTasksComponent,
    children: [
      {
        path: "tasks",
        component: TasksComponent,
      },
    ],
  },
];
```

Sau đó imports `RouterOutlet` vào component cha và sử dụng `<router-outlet></router-outlet>` trong template của component cha để hiển thị các thành phần trang con.

> Lưu ý: Trong các route con, việc đọc các params từ url của route cha không thể thực hiện bằng mỗi `ActivatedRoute` hay `withComponentInputBinding()` được. Để sử dụng, chúng ta thêm tham số thứ 3 vào trong `provideRouter`. Đó chính là `withRouterConfig`

```ts
import {
  provideRouter,
  withComponentInputBinding,
  withRouterConfig,
} from "@angular/router";
import { ApplicationConfig } from "@angular/core";
import { routes } from "./app.routes";

export const appConfig: ApplicationConfig = {
  providers: [
    provideRouter(
      routes,
      withComponentInputBinding(),
      withRouterConfig({
        paramsInheritanceStrategy: "always", // Cho phép kế thừa tham số từ route cha
      })
    ),
  ],
};
```

### 3.4. Đường dẫn tương đối - tuyệt đối
Đường dẫn tương đối (relative path) là đường dẫn được xác định dựa trên vị trí hiện tại của route. Trong khi đó, đường dẫn tuyệt đối (absolute path) là đường dẫn bắt đầu từ gốc của ứng dụng.

Ví dụ:

- Đường dẫn tương đối: `tasks/new` (không có dấu `/` ở đầu => nó sẽ xác định bằng `đường dẫn hiện tại` + `/tasks/new`)
- Đường dẫn tuyệt đối: `/users/:userId/tasks/new` (bắt đầu bằng dấu `/`, xác định từ gốc ứng dụng)

> Lưu ý đối với các `dynamic route`: Khi sử dụng đường dẫn tuyệt đối, việc xác định các tham số động (như `:userId`) là khó, 1 cách để bỏ qua điều này là sử dụng dấu `...` để chỉ định các tham số động. VD: `/users/.../tasks/new`

Khi sử dụng `../` để quay lại một cấp trong cấu trúc thư mục, bạn có thể dễ dàng điều hướng đến các route cha mà không cần phải chỉ định đầy đủ đường dẫn tuyệt đối. (quy cách giống như trong hệ thống file)

### 3.5. Điều hướng lại trang khác (redirect)
Điều hướng lại trang khác (redirect) cho phép bạn tự động chuyển hướng người dùng từ một route này sang một route khác. Điều này rất hữu ích khi bạn muốn thay đổi cấu trúc URL hoặc khi một route đã bị xóa và bạn muốn chuyển hướng người dùng đến một route mới.

Để định nghĩa một redirect trong Angular, bạn có thể sử dụng thuộc tính `redirectTo` trong đối tượng route. Tiếp theo thuộc tính `pathMatch` sẽ xác định cách mà Angular sẽ so khớp URL hiện tại với đường dẫn đã định nghĩa, giá trị `pathMatch` có thể là:

- `full`: So khớp toàn bộ URL (bao gồm cả đường dẫn và tham số truy vấn - nên dùng ở route con bên trong)
- `prefix`: So khớp phần đầu của URL (chỉ cần khớp với đường dẫn - không nên dùng ở route cha bên ngoài, vì có thể mặc định bên ngoài path là chuỗi rỗng)

Ví dụ:

```ts
import { Routes } from "@angular/router";
import { NotFoundComponent } from "./not-found/not-found.component";

const routes: Routes = [
  {
    path: "",
    redirectTo: "/users",
    pathMatch: "full"
  },
  {
    path: "users",
    component: UserTasksComponent,
    children: [
      {
        path: "",
        redirectTo: "tasks",
        pathMatch: "prefix"
      }
    ]
  },
  {
    path: "**",
    component: NotFoundComponent
  }
];
```

```ts
import { Routes } from "@angular/router";
import { NotFoundComponent } from "./not-found/not-found.component";

const routes: Routes = [
  {
    path: "",
    redirectTo: "/users",
    pathMatch: "full"
  },
  {
    path: "**",
    component: NotFoundComponent
  }
];
```

### 3.6. Sử dụng tham số truy vấn URL (Query Param)

Tham số truy vấn URL (query param) cho phép bạn truyền dữ liệu từ một route này sang một route khác thông qua URL. Điều này rất hữu ích khi bạn muốn lọc hoặc sắp xếp dữ liệu dựa trên các tiêu chí cụ thể.

Để thêm tham số truy vấn vào một route, bạn có thể sử dụng thuộc tính `queryParams` trong `RouterLink` được imports vào component của bạn.

```ts
import { Component } from '@angular/core';
import { RouterLink } from '@angular/router';

@Component({
  selector: 'app-example',
  templateUrl: './example.component.html',
  styleUrls: ['./example.component.css'],
  imports: [RouterLink]
})
```

Sau đó, bạn thêm thuộc tính `queryParams` vào `RouterLink` như sau:

```html
<p>
  <a routerLink="./" [queryParams]="{order: order() === 'asc' ? 'desc' : 'asc'}"> <!-- URL: <url đang trỏ đến>?order=asc|desc -->
    {{ order() === 'asc' ? 'Sort Descending' : 'Sort Ascending' }}
  </a>
</p>
```

Trong component, để đọc các tham số truy vấn, bạn có thể sử dụng đối tượng `ActivatedRoute` hoặc sử dụng `input` (với điều kiện đã import hàm `withComponentInputBindings`). Và vì tham số truy vấn có thể thay đổi, bạn nên sử dụng `Observable` hoặc `signal` để theo dõi sự thay đổi của chúng.
```ts
import { Component, computed, inject, input } from "@angular/core";

import { TaskComponent } from "./task/task.component";
import { Task } from "./task/task.model";
import { TasksService } from "./tasks.service";

@Component({
  selector: "app-tasks",
  standalone: true,
  templateUrl: "./tasks.component.html",
  styleUrl: "./tasks.component.css",
  imports: [TaskComponent],
})
export class TasksComponent {
  private taskService = inject(TasksService);
  userId = input.required<string>();
  order = input.required<"asc" | "desc">(); // Đọc từ query param url

// Hoặc sử dụng Observable

  // order = signal<"asc" | "desc">("asc");

  // order: "asc" | "desc" = "asc";
  // ngOnInit(): void {
  //   console.log(this.activatedRoute);
  //   const sub = this.activatedRoute.params.subscribe({
  //     next: (params) => {
  //       this.username.set(params["order"]); // Lấy giá trị từ query param có key "order" rồi set vào signal
  //     },
  //   });
  //   this.destroyRef.onDestroy(() => sub.unsubscribe());
  // }

  userTasks = computed(() =>
    this.taskService.allTasks().filter((t) => t.userId === this.userId()).sort((a, b) => {
      if (this.order() === "asc") {
        return a.title.localeCompare(b.title);
      } else {
        return b.title.localeCompare(a.title);
      }
    })
  );
}
```

### 3.7. Truyền dữ liệu vào trong Component
Ngoài cách truyền dữ liệu vào URL thông qua param, query ra (có nhiều hạn chế) thì bạn có thể sử dụng các kỹ thuật khác mà Angukar Router hỗ trợ, thông qua `data` (truyền dữ liệu tĩnh) và `resolve` (truyền dữ liệu động)

#### 3.7.1. Truyền dữ liệu tĩnh.
Để truyền dữ liệu tĩnh, ta thêm thuộc tính `data` vào route như sau:

```ts
const routes: Routes = [
  {
    path: 'example',
    component: ExampleComponent,
    data: {
      title: 'Example Page',
      description: 'This is an example page.'
    } // Thông tin dữ liệu sẽ được truyền vào component thông qua ActivatedRoute hoặc withComponentInputBindings
  }
];
```

Trong component, lấy thông tin từ `ActivatedRoute`.
```ts
import { Component, inject } from '@angular/core';
import { ActivatedRoute } from '@angular/router';

@Component({
  selector: 'app-example',
  templateUrl: './example.component.html',
  styleUrls: ['./example.component.css']
})
export class ExampleComponent {
  private activatedRoute = inject(ActivatedRoute);
  private destroyRef = inject(ngDestroyRef);
  title = signal<string>();
  description = signal<string>();
  ngOnInit(): void {
    const sub = this.activatedRoute.data.subscribe({
      next: (data) => {
        this.title.set(data['title']);
        this.description.set(data['description']);
      }
    });
    this.destroyRef.onDestroy(() => sub.unsubscribe());
  }
}
```

Hoặc có thể dùng `input` bằng cách thêm `withComponentInputBindings` vào cấu hình:
```ts
import { Component, inject } from '@angular/core';
import { ActivatedRoute } from '@angular/router';

@Component({
  selector: 'app-example',
  templateUrl: './example.component.html',
  styleUrls: ['./example.component.css']
})
export class ExampleComponent {
  title: input<string>();
  description: input<string>();
}
```

Trong template, bạn có thể sử dụng dữ liệu đã truyền vào, lưu ý với `input` thì dữ liệu sẽ là kiểu `signal`.
```html
<h1>{{ title() }}</h1>
<p>{{ description() }}</p>
```

#### 3.7.2. Truyền dữ liệu động.
Để truyền dữ liệu động, ta sử dụng thuộc tính `resolve` trong cấu hình route, tham số của `resolve` sẽ là 1 function (nên dùng) hoặc class (khuyên bỏ)

##### 3.7.2.1. Sử dụng class
Với class, bạn có thể tạo một class implement interface `Resolve` và định nghĩa phương thức `resolve` để lấy dữ liệu và cần thêm annotation `@Injectable` cho các class này.

Hàm kế thừa sẽ nhận vào 2 tham số là `ActivatedRouteSnapshot` và `RouterStateSnapshot`, bạn có thể sử dụng chúng để lấy thông tin từ route hoặc state hiện tại.

```ts
import { Injectable } from '@angular/core';
import { Resolve, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';
import { Observable } from 'rxjs';
import { TaskService } from './task.service';

@Injectable({
  providedIn: 'root'
})
export class TaskResolver implements Resolve<{ title: string; description: string }> {
  constructor(private taskService: TaskService) {}

  resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<{ title: string; description: string }> {
    const taskId = route.paramMap.get('id');
    return this.taskService.getTaskById(taskId);
  }
}
```

Sau đó, trong cấu hình route, ta thêm `resolve` vào route cần truyền dữ liệu:

```ts
const routes: Routes = [
  {
    path: 'task/:id',
    component: TaskDetailComponent,
    resolve: {
      task: TaskResolver
    }
  }
];
```

Trong component, lấy thông tin từ `ActivatedRoute` bằng cách gọi `snapshot`:

```ts
import { Component, inject } from '@angular/core';
import { ActivatedRoute } from '@angular/router';

@Component({
  selector: 'app-task-detail',
  templateUrl: './task-detail.component.html',
  styleUrls: ['./task-detail.component.css']
})
export class TaskDetailComponent {
  private activatedRoute = inject(ActivatedRoute);
  private destroyRef = inject(ngDestroyRef);
  task = signal<{ title: string; description: string }>();

  ngOnInit(): void {
    const sub = this.activatedRoute.data.subscribe({
      next: (data) => {
        const task = data['task'];
        this.task.set(task);
        console.log(task);
      }
    });
    this.destroyRef.onDestroy(() => sub.unsubscribe());
  }
}
```

Hoặc bạn có thể sử dụng `input` với cấu hình `withComponentInputBindings`:

```ts
import { Component, inject } from '@angular/core';
import { ActivatedRoute } from '@angular/router';

@Component({
  selector: 'app-example',
  templateUrl: './example.component.html',
  styleUrls: ['./example.component.css']
})
export class ExampleComponent {
  task: input<{ title: string; description: string }>();
}
```

Trong template, bạn có thể sử dụng dữ liệu đã truyền vào, lưu ý với `input` thì dữ liệu sẽ là kiểu `signal`.
```html
<h1>{{ task().title }}</h1>
<p>{{ task().description }}</p>
```

##### 3.7.2.2. Sử dụng function
```ts
import { Injectable } from '@angular/core';
import { ResolveFn } from '@angular/router';
import { Observable } from 'rxjs';
import { TaskService } from './task.service';

export const taskResolver: ResolveFn<{ title: string; description: string }> = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => {
  const taskService = inject(TaskService);
  const taskId = route.paramMap.get('id');
  return this.taskService.getTaskById(taskId);
};
```

Sau đó truyền vào `resolve` và sử dụng tương tự như cách làm với class.

> **Lưu ý**: Khi lấy dữ liệu từ data (không phải từ URL) thì sử dụng `paramMap` thay vì `params`.

> **ĐĂC BIỆT LƯU Ý**: Khi sử dụng `resolve` cần phải đảm bảo thêm thuộc tính đi kèm là `runGuardsAndResolvers`.
`runGuardsAndResolvers` có tác dụng đảm bảo rằng các guard và resolver sẽ được thực thi trước khi kích hoạt route. Làm cho các trang buộc phải cập nhật dữ liệu mới khi dư liệu trong resolver thay đổi. `runGuardsAndResolvers` có thể được cấu hình trong route như sau:

```ts
const routes: Routes = [
  {
    path: 'task/:id',
    component: TaskDetailComponent,
    resolve: {
      task: TaskResolver
    },
    runGuardsAndResolvers: 'always' // đảm bảo rằng các guard và resolver sẽ được thực thi trước khi kích hoạt route
    // runGuardsAndResolvers: 'paramsChange' // chỉ thực thi khi tham số trong route thay đổi
    // runGuardsAndResolvers: 'pathChange' // chỉ thực thi khi đường dẫn trong route thay đổi
    // runGuardsAndResolvers: 'always' // luôn thực thi
    // runGuardsAndResolvers: 'paramsOrQueryParamsChange' // chỉ thực thi khi tham số hoặc truy vấn trong route thay đổi
    // runGuardsAndResolvers: 'pathParamsOrQueryParamsChange' // chỉ thực thi khi đường dẫn hoặc truy vấn trong route thay đổi
  }
];
```

### 3.8. Lazy Loading với `loadComponent` và `loadChildren`
#### 3.8.1. So sánh `loadComponent` và `loadChildren`

- `loadComponent`: Tải một thành phần cụ thể khi cần thiết. Thích hợp cho các thành phần độc lập, không phụ thuộc vào các thành phần khác (standalone)
- `loadChildren`: Tải một module con (child module) cùng với tất cả các thành phần, dịch vụ và các tài nguyên khác của nó. Thích hợp cho việc chia nhỏ ứng dụng thành các module lớn hơn, giúp cải thiện hiệu suất và khả năng bảo trì. (module)

#### 3.8.2. Ví dụ sử dụng `loadComponent` và `loadChildren`
```ts
import { loadComponent } from '@angular/core';

const routes: Routes = [
  {
    path: 'lazy',
    loadComponent: () => import('./lazy/lazy.component').then(m => m.LazyComponent)
  }
];
```

```ts
import { loadChildren } from '@angular/core';

const routes: Routes = [
  {
    path: 'admin',
    loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule)
  }
];
```
