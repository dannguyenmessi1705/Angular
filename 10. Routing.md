# Routing
## 1. Giới thiệu
- Routing trong Angular cho phép điều hướng giữa các thành phần khác nhau trong ứng dụng. Nó giúp quản lý các URL và hiển thị các thành phần tương ứng dựa trên URL hiện tại.
- Angular Router là một module mạnh mẽ cho phép bạn định nghĩa các tuyến đường (routes) trong ứng dụng của mình.
- Trong Angular nhờ routing có thể xây dựng các ứng dụng một trang (Single Page Applications - SPA) và ứng dụng đa trang (Multi-Page Applications - MPA).

## 2. Cấu hình Routing cơ bản

Để cấu hình routing trong Angular, bạn cần định nghĩa các tuyến đường (routes) trong ứng dụng của mình. Các tuyến đường này sẽ ánh xạ các URL đến các thành phần tương ứng.

### 2.1. Định nghĩa Routes

Trong Angular, bạn có thể định nghĩa các routes trong một file riêng biệt, thường là `app.routes.ts`. Dưới đây là một ví dụ về cách định nghĩa các routes:

```typescript
import { Routes } from "@angular/router";
import { TaskComponent } from "./tasks/task/task.component";
import { NoTaskComponent } from "./tasks/no-task/no-task.component";

export const routes: Routes = [
  {
    path: "", // <domain>/
    component: NoTaskComponent,
  },
  {
    path: "tasks", // <domain>/tasks
    component: TaskComponent,
  },
  {
    path: "**",
    component: ErrorComponent
  }
];
```
> Nên định nghĩa một component ErrorComponent để hiển thị thông báo lỗi khi không tìm thấy route ở cuối cùng (mức ưu tiên thấp nhất)

### 2.2. Cấu hình Config cho `main.ts`

Sau khi định nghĩa các routes, bạn cần cấu hình bật Router rồi import vào trong `providers` bằng cách tạo `app.config.ts`:

```typescript
import { provideRouter } from "@angular/router";
import { ApplicationConfig } from "@angular/core";
import { routes } from "./app.routes";

export const appConfig: ApplicationConfig = {
  providers: [
    provideRouter(routes) // Cấu hình Router, cho phép điều hướng giữa các thành phần
  ],
};
```
Sau đó thêm cấu hình vào trong `main.ts`:

```typescript
import { bootstrapApplication } from "@angular/platform-browser";

import { AppComponent } from "./app/app.component";
import { appConfig } from "./app/app.config";

bootstrapApplication(AppComponent, appConfig).catch((err) =>
  console.error(err)
);

```

### 2.3. Sử dụng `<router-outlet>`
Router Outlet là một chỉ thị trong Angular cho phép bạn hiển thị các thành phần tương ứng với các tuyến đường đã định nghĩa. Để sử dụng Router Outlet, bạn cần thêm nó vào trong template của thành phần cha.

Ví dụ: `app.component.html`

```html
<app-header />

<main>
  <app-users />

  <div>
    <router-outlet />
  </div>
</main>

```

Sau đó import `RouterOutlet` vào trong `component` đang sử dụng
```ts
import { Component } from '@angular/core';

import { HeaderComponent } from './header/header.component';
import { UsersComponent } from './users/users.component';
import { RouterOutlet } from '@angular/router';

@Component({
  selector: 'app-root',
  standalone: true,
  templateUrl: './app.component.html',
  styleUrl: './app.component.css',
  imports: [HeaderComponent, UsersComponent, RouterOutlet],
})
export class AppComponent {}
```

> Khi người dùng điều hướng đến một tuyến đường cụ thể, Angular sẽ tự động thay thế nội dung của Router Outlet bằng thành phần tương ứng với tuyến đường đó. (Chỉ hiển thị một thành phần `Router Outlet` tại một thời điểm, còn tất cả các thẻ khác không phải `Router Outlet` vẫn sẽ được giữ nguyên).


## 3. Routing nâng cao
### 3.1. Điều hướng giữa các thành phần
Thông thường thẻ `a` sẽ được sử dụng để điều hướng giữa các thành phần trong web bằng thuộc tính `href`. Tuy nhiên nó sẽ làm web bị tải lại toàn bộ trang và sẽ mất đi trạng thái của ứng dụng. Vì thế trong Angular, bạn có thể sử dụng thuộc tính `routerLink` để chỉ định tuyến đường mà bạn muốn điều hướng đến mà không làm mất đi trạng thái của ứng dụng.
Ví dụ:

```html
<a routerLink="/tasks">Đi đến trang Tasks</a>
```

Sau đó, trong `component` của template này, ta import thêm `RouterLink` vào trong `component` đang sử dụng
```ts
import { Component } from '@angular/core';

import { HeaderComponent } from './header/header.component';
import { UsersComponent } from './users/users.component';
import { RouterLink } from '@angular/router';

@Component({
  selector: 'app-root',
  standalone: true,
  templateUrl: './app.component.html',
  styleUrl: './app.component.css',
  imports: [HeaderComponent, UsersComponent, RouterLink],
})
export class AppComponent {}

```

> Khi người dùng nhấp vào liên kết này, Angular sẽ điều hướng đến tuyến đường `/tasks` và hiển thị thành phần tương ứng với tuyến đường đó trong Router Outlet.

Ngoài ra Angular còn cung cấp thêm class styles cho các đường link được active nhờ sử dụng `routerLinkActive`.
```html
<a routerLink="/tasks" routerLinkActive="selected">Đi đến trang Tasks</a>
```
Sau đó thêm `RouterLinkActive` vào phần `imports` của `Component`.

> Có thể truyền vào `routerLink` một mảng các tham số, sau đó Angular sẽ tự động ghép chúng lại thành một đường dẫn ngăn cách bằng dấu `/`. (Ví dụ: `[routerLink]="['/tasks', task().id]"` sẽ tạo thành đường dẫn `/tasks/1` nếu `task().id` là `1`) hoặc `[routerLink]="'/tasks/' + task().id"` hoặc `routerLink="{{'/tasks/' + task().id}}"`.

Sử dụng **điều hướng lập trình (Programmatic Navigation)** cho phép bạn điều hướng đến các route một cách linh hoạt hơn khi đang xử lý logic trong component. Để làm điều này chúng ta cần inject `Router` vào trong component.
```ts
import { Component } from '@angular/core';
import { Router } from '@angular/router';

@Component({
  selector: 'app-example',
  templateUrl: './example.component.html',
  styleUrls: ['./example.component.css']
})
export class ExampleComponent {
  constructor(private router: Router) {}

  navigateToTasks() {
    this.router.navigate(['/tasks'], {
      queryParams: { userId: 123 }, // Thêm tham số truy vấn (/tasks?userId=123)
      replaceUrl: true // Thay thế URL hiện tại (không thêm vào lịch sử, và người dùng không thể quay lại trang trước đó)
    });
  }
}

```

### 3.2. Điều hướng tới các route động (Dynamic Routing)
Dynamic Routing cho phép bạn định nghĩa các tuyến đường với các tham số động. Điều này rất hữu ích khi bạn cần hiển thị nội dung khác nhau dựa trên các tham số trong URL.

Ví dụ: Giả sử bạn có một trang chi tiết cho từng tác vụ và bạn muốn điều hướng đến trang đó với ID của tác vụ. Bạn có thể định nghĩa một tuyến đường như sau:

```ts
const routes: Routes = [
  {
    path: 'tasks/:id',
    component: TaskDetailComponent
  }
];
```
> `:id` là một tham số động (paramete của đường dẫn)

Trong ví dụ này, `:id` là một tham số động. Khi người dùng điều hướng đến `/tasks/1`, Angular sẽ hiển thị `TaskDetailComponent` và bạn có thể truy cập ID của tác vụ thông qua `ActivatedRoute`.

#### 3.2.1. Truy cập tham số động trong component với Input

Để truy cập tham số động trong component, bạn có thể sử dụng `withComponentInputBinding()` làm đối số thứ hai của `provideRouter` trong list provider của bạn. `withComponentInputBinding()` cho phép bạn ánh xạ các tham số route thành các thuộc tính đầu vào của component (bao gồm `dynamicRoute`, `data`, `title`, `resolver`,..). Ví dụ

```ts
import { provideRouter, withComponentInputBinding } from "@angular/router";
import { ApplicationConfig } from "@angular/core";
import { routes } from "./app.routes";

export const appConfig: ApplicationConfig = {
  providers: [provideRouter(routes, withComponentInputBinding())],
};
```

Sau đó sử dụng `input` trong component của bạn để nhận giá trị của tham số động. Với điều kiện là biến đặt tên giống với tên tham số trong route và phải thêm điều kiện là bắt buộc `input.required`.

```ts
import {
  Component,
  computed,
  DestroyRef,
  inject,
  Input,
  input,
  OnInit,
} from "@angular/core";
import { UsersService } from "../users.service";
import { ActivatedRoute } from "@angular/router";

@Component({
  selector: "app-user-tasks",
  standalone: true,
  templateUrl: "./user-tasks.component.html",
  styleUrl: "./user-tasks.component.css",
})
export class UserTasksComponent implements OnInit {
  private userService = inject(UsersService);
  userId = input.required<string>();
  username = computed(
    () => this.userService.users.find((u) => u.id === this.userId()?.name
  );
}

```

#### 3.2.2. Truy cập tham số động bằng Observable

Để truy cập tham số động bằng Observable, bạn có thể sử dụng `ActivatedRoute` để lấy thông tin về route hiện tại. Và không cần phải thêm tham số thứ 2 là `withComponentInputBinding()` vào `provideRouter`.

```ts
import {
  Component,
  computed,
  DestroyRef,
  inject,
  Input,
  input,
  OnInit,
} from "@angular/core";
import { UsersService } from "../users.service";
import { ActivatedRoute } from "@angular/router";

@Component({
  selector: "app-user-tasks",
  standalone: true,
  templateUrl: "./user-tasks.component.html",
  styleUrl: "./user-tasks.component.css",
})
export class UserTasksComponent implements OnInit {
  private userService = inject(UsersService);

  username: string = "";
  private destroyRef = inject(DestroyRef);
  private activatedRoute = inject(ActivatedRoute);

  ngOnInit(): void {
    console.log(this.activatedRoute);
    const sub = this.activatedRoute.params.subscribe({
      next: (params) => {
        this.username =
          this.userService.users.find((u) => u.id === params["userId"])?.name ??
          "";
      },
    });
    this.destroyRef.onDestroy(() => sub.unsubscribe());
  }
}

```

### 3.3. Nested Routes (Child Routes)
Nested Routes (Child Routes) cho phép bạn định nghĩa các tuyến đường con bên trong một tuyến đường cha. Điều này rất hữu ích khi bạn muốn tổ chức các thành phần của mình theo cấu trúc phân cấp.

Chỉ cần thêm thuộc tính `children` vào đối tượng route cha và định nghĩa các tuyến đường con bên trong mảng `children` như cách định nghĩa các tuyến đường thông thường route cha.

VD: Tạo 1 route như sau `/users/:userId/tasks` để hiển thị các nhiệm vụ của người dùng cụ thể.

```ts
import { Routes } from "@angular/router";
import { UserTasksComponent } from "./users/user-tasks/user-tasks.component";

const routes: Routes = [
  {
    path: "users/:userId",
    component: UserTasksComponent,
    children: [
      {
        path: "tasks",
        component: TasksComponent,
      },
    ],
  },
];
```

Sau đó imports `RouterOutlet` vào component cha và sử dụng `<router-outlet></router-outlet>` trong template của component cha để hiển thị các thành phần trang con.

> Lưu ý: Trong các route con, việc đọc các params từ url của route cha không thể thực hiện bằng mỗi `ActivatedRoute` hay `withComponentInputBinding()` được. Để sử dụng, chúng ta thêm tham số thứ 3 vào trong `provideRouter`. Đó chính là `withRouterConfig`

```ts
import {
  provideRouter,
  withComponentInputBinding,
  withRouterConfig,
} from "@angular/router";
import { ApplicationConfig } from "@angular/core";
import { routes } from "./app.routes";

export const appConfig: ApplicationConfig = {
  providers: [
    provideRouter(
      routes,
      withComponentInputBinding(),
      withRouterConfig({
        paramsInheritanceStrategy: "always", // Cho phép kế thừa tham số từ route cha
      })
    ),
  ],
};
```

### 3.4. Đường dẫn tương đối - tuyệt đối
Đường dẫn tương đối (relative path) là đường dẫn được xác định dựa trên vị trí hiện tại của route. Trong khi đó, đường dẫn tuyệt đối (absolute path) là đường dẫn bắt đầu từ gốc của ứng dụng.

Ví dụ:

- Đường dẫn tương đối: `tasks/new` (không có dấu `/` ở đầu => nó sẽ xác định bằng `đường dẫn hiện tại` + `/tasks/new`)
- Đường dẫn tuyệt đối: `/users/:userId/tasks/new` (bắt đầu bằng dấu `/`, xác định từ gốc ứng dụng)

> Lưu ý đối với các `dynamic route`: Khi sử dụng đường dẫn tuyệt đối, việc xác định các tham số động (như `:userId`) là khó, 1 cách để bỏ qua điều này là sử dụng dấu `...` để chỉ định các tham số động. VD: `/users/.../tasks/new`

Khi sử dụng `../` để quay lại một cấp trong cấu trúc thư mục, bạn có thể dễ dàng điều hướng đến các route cha mà không cần phải chỉ định đầy đủ đường dẫn tuyệt đối. (quy cách giống như trong hệ thống file)

### 3.5. Điều hướng lại trang khác (redirect)
Điều hướng lại trang khác (redirect) cho phép bạn tự động chuyển hướng người dùng từ một route này sang một route khác. Điều này rất hữu ích khi bạn muốn thay đổi cấu trúc URL hoặc khi một route đã bị xóa và bạn muốn chuyển hướng người dùng đến một route mới.

Để định nghĩa một redirect trong Angular, bạn có thể sử dụng thuộc tính `redirectTo` trong đối tượng route. Tiếp theo thuộc tính `pathMatch` sẽ xác định cách mà Angular sẽ so khớp URL hiện tại với đường dẫn đã định nghĩa, giá trị `pathMatch` có thể là:

- `full`: So khớp toàn bộ URL (bao gồm cả đường dẫn và tham số truy vấn - nên dùng ở route con bên trong)
- `prefix`: So khớp phần đầu của URL (chỉ cần khớp với đường dẫn - không nên dùng ở route cha bên ngoài, vì có thể mặc định bên ngoài path là chuỗi rỗng)

Ví dụ:

```ts
import { Routes } from "@angular/router";
import { NotFoundComponent } from "./not-found/not-found.component";

const routes: Routes = [
  {
    path: "",
    redirectTo: "/users",
    pathMatch: "full"
  },
  {
    path: "users",
    component: UserTasksComponent,
    children: [
      {
        path: "",
        redirectTo: "tasks",
        pathMatch: "prefix"
      }
    ]
  },
  {
    path: "**",
    component: NotFoundComponent
  }
];
```

```ts
import { Routes } from "@angular/router";
import { NotFoundComponent } from "./not-found/not-found.component";

const routes: Routes = [
  {
    path: "",
    redirectTo: "/users",
    pathMatch: "full"
  },
  {
    path: "**",
    component: NotFoundComponent
  }
];
```

### 3.6. Sử dụng tham số truy vấn URL (Query Param)

Tham số truy vấn URL (query param) cho phép bạn truyền dữ liệu từ một route này sang một route khác thông qua URL. Điều này rất hữu ích khi bạn muốn lọc hoặc sắp xếp dữ liệu dựa trên các tiêu chí cụ thể.

Để thêm tham số truy vấn vào một route, bạn có thể sử dụng thuộc tính `queryParams` trong `RouterLink` được imports vào component của bạn.

```ts
import { Component } from '@angular/core';
import { RouterLink } from '@angular/router';

@Component({
  selector: 'app-example',
  templateUrl: './example.component.html',
  styleUrls: ['./example.component.css'],
  imports: [RouterLink]
})
```

Sau đó, bạn thêm thuộc tính `queryParams` vào `RouterLink` như sau:

```html
<p>
  <a routerLink="./" [queryParams]="{order: order() === 'asc' ? 'desc' : 'asc'}"> <!-- URL: <url đang trỏ đến>?order=asc|desc -->
    {{ order() === 'asc' ? 'Sort Descending' : 'Sort Ascending' }}
  </a>
</p>
```

Trong component, để đọc các tham số truy vấn, bạn có thể sử dụng đối tượng `ActivatedRoute` hoặc sử dụng `input` (với điều kiện đã import hàm `withComponentInputBindings`). Và vì tham số truy vấn có thể thay đổi, bạn nên sử dụng `Observable` hoặc `signal` để theo dõi sự thay đổi của chúng.
```ts
import { Component, computed, inject, input } from "@angular/core";

import { TaskComponent } from "./task/task.component";
import { Task } from "./task/task.model";
import { TasksService } from "./tasks.service";

@Component({
  selector: "app-tasks",
  standalone: true,
  templateUrl: "./tasks.component.html",
  styleUrl: "./tasks.component.css",
  imports: [TaskComponent],
})
export class TasksComponent {
  private taskService = inject(TasksService);
  userId = input.required<string>();
  order = input.required<"asc" | "desc">(); // Đọc từ query param url

// Hoặc sử dụng Observable

  // order = signal<"asc" | "desc">("asc");

  // order: "asc" | "desc" = "asc";
  // ngOnInit(): void {
  //   console.log(this.activatedRoute);
  //   const sub = this.activatedRoute.params.subscribe({
  //     next: (params) => {
  //       this.username.set(params["order"]); // Lấy giá trị từ query param có key "order" rồi set vào signal
  //     },
  //   });
  //   this.destroyRef.onDestroy(() => sub.unsubscribe());
  // }

  userTasks = computed(() =>
    this.taskService.allTasks().filter((t) => t.userId === this.userId()).sort((a, b) => {
      if (this.order() === "asc") {
        return a.title.localeCompare(b.title);
      } else {
        return b.title.localeCompare(a.title);
      }
    })
  );
}
```

### 3.7. Truyền dữ liệu vào trong Component
Ngoài cách truyền dữ liệu vào URL thông qua param, query ra (có nhiều hạn chế) thì bạn có thể sử dụng các kỹ thuật khác mà Angukar Router hỗ trợ, thông qua `data` (truyền dữ liệu tĩnh) và `resolve` (truyền dữ liệu động)

#### 3.7.1. Truyền dữ liệu tĩnh.
Để truyền dữ liệu tĩnh, ta thêm thuộc tính `data` vào route như sau:

```ts
const routes: Routes = [
  {
    path: 'example',
    component: ExampleComponent,
    data: {
      title: 'Example Page',
      description: 'This is an example page.'
    } // Thông tin dữ liệu sẽ được truyền vào component thông qua ActivatedRoute hoặc withComponentInputBindings
  }
];
```

Trong component, lấy thông tin từ `ActivatedRoute`.
```ts
import { Component, inject } from '@angular/core';
import { ActivatedRoute } from '@angular/router';

@Component({
  selector: 'app-example',
  templateUrl: './example.component.html',
  styleUrls: ['./example.component.css']
})
export class ExampleComponent {
  private activatedRoute = inject(ActivatedRoute);
  private destroyRef = inject(ngDestroyRef);
  title = signal<string>();
  description = signal<string>();
  ngOnInit(): void {
    const sub = this.activatedRoute.data.subscribe({
      next: (data) => {
        this.title.set(data['title']);
        this.description.set(data['description']);
      }
    });
    this.destroyRef.onDestroy(() => sub.unsubscribe());
  }
}
```

Hoặc có thể dùng `input` bằng cách thêm `withComponentInputBindings` vào cấu hình:
```ts
import { Component, inject } from '@angular/core';
import { ActivatedRoute } from '@angular/router';

@Component({
  selector: 'app-example',
  templateUrl: './example.component.html',
  styleUrls: ['./example.component.css']
})
export class ExampleComponent {
  title: input<string>();
  description: input<string>();
}
```

Trong template, bạn có thể sử dụng dữ liệu đã truyền vào, lưu ý với `input` thì dữ liệu sẽ là kiểu `signal`.
```html
<h1>{{ title() }}</h1>
<p>{{ description() }}</p>
```

#### 3.7.2. Truyền dữ liệu động.
Để truyền dữ liệu động, ta sử dụng thuộc tính `resolve` trong cấu hình route, tham số của `resolve` sẽ là 1 function (nên dùng) hoặc class (khuyên bỏ)

##### 3.7.2.1. Sử dụng class
Với class, bạn có thể tạo một class implement interface `Resolve` và định nghĩa phương thức `resolve` để lấy dữ liệu và cần thêm annotation `@Injectable` cho các class này.

Hàm kế thừa sẽ nhận vào 2 tham số là `ActivatedRouteSnapshot` và `RouterStateSnapshot`, bạn có thể sử dụng chúng để lấy thông tin từ route hoặc state hiện tại.

```ts
import { Injectable } from '@angular/core';
import { Resolve, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';
import { Observable } from 'rxjs';
import { TaskService } from './task.service';

@Injectable({
  providedIn: 'root'
})
export class TaskResolver implements Resolve<{ title: string; description: string }> {
  constructor(private taskService: TaskService) {}

  resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<{ title: string; description: string }> {
    const taskId = route.paramMap.get('id');
    return this.taskService.getTaskById(taskId);
  }
}
```

Sau đó, trong cấu hình route, ta thêm `resolve` vào route cần truyền dữ liệu:

```ts
const routes: Routes = [
  {
    path: 'task/:id',
    component: TaskDetailComponent,
    resolve: {
      task: TaskResolver
    }
  }
];
```

Trong component, lấy thông tin từ `ActivatedRoute` bằng cách gọi `snapshot`:

```ts
import { Component, inject } from '@angular/core';
import { ActivatedRoute } from '@angular/router';

@Component({
  selector: 'app-task-detail',
  templateUrl: './task-detail.component.html',
  styleUrls: ['./task-detail.component.css']
})
export class TaskDetailComponent {
  private activatedRoute = inject(ActivatedRoute);
  private destroyRef = inject(ngDestroyRef);
  task = signal<{ title: string; description: string }>();

  ngOnInit(): void {
    const sub = this.activatedRoute.data.subscribe({
      next: (data) => {
        const task = data['task'];
        this.task.set(task);
        console.log(task);
      }
    });
    this.destroyRef.onDestroy(() => sub.unsubscribe());
  }
}
```

Hoặc bạn có thể sử dụng `input` với cấu hình `withComponentInputBindings`:

```ts
import { Component, inject } from '@angular/core';
import { ActivatedRoute } from '@angular/router';

@Component({
  selector: 'app-example',
  templateUrl: './example.component.html',
  styleUrls: ['./example.component.css']
})
export class ExampleComponent {
  task: input<{ title: string; description: string }>();
}
```

Trong template, bạn có thể sử dụng dữ liệu đã truyền vào, lưu ý với `input` thì dữ liệu sẽ là kiểu `signal`.
```html
<h1>{{ task().title }}</h1>
<p>{{ task().description }}</p>
```

##### 3.7.2.2. Sử dụng function
```ts
import { Injectable } from '@angular/core';
import { ResolveFn } from '@angular/router';
import { Observable } from 'rxjs';
import { TaskService } from './task.service';

export const taskResolver: ResolveFn<{ title: string; description: string }> = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => {
  const taskService = inject(TaskService);
  const taskId = route.paramMap.get('id');
  return this.taskService.getTaskById(taskId);
};
```

Sau đó truyền vào `resolve` và sử dụng tương tự như cách làm với class.

> **Lưu ý**: Khi lấy dữ liệu từ data (không phải từ URL) thì sử dụng `paramMap` thay vì `params`.

> **ĐĂC BIỆT LƯU Ý**: Khi sử dụng `resolve` cần phải đảm bảo thêm thuộc tính đi kèm là `runGuardsAndResolvers`.
`runGuardsAndResolvers` có tác dụng đảm bảo rằng các guard và resolver sẽ được thực thi trước khi kích hoạt route. Làm cho các trang buộc phải cập nhật dữ liệu mới khi dư liệu trong resolver thay đổi. `runGuardsAndResolvers` có thể được cấu hình trong route như sau:

```ts
const routes: Routes = [
  {
    path: 'task/:id',
    component: TaskDetailComponent,
    resolve: {
      task: TaskResolver
    },
    runGuardsAndResolvers: 'always' // đảm bảo rằng các guard và resolver sẽ được thực thi trước khi kích hoạt route
    // runGuardsAndResolvers: 'paramsChange' // chỉ thực thi khi tham số trong route thay đổi
    // runGuardsAndResolvers: 'pathChange' // chỉ thực thi khi đường dẫn trong route thay đổi
    // runGuardsAndResolvers: 'always' // luôn thực thi
    // runGuardsAndResolvers: 'paramsOrQueryParamsChange' // chỉ thực thi khi tham số hoặc truy vấn trong route thay đổi
    // runGuardsAndResolvers: 'pathParamsOrQueryParamsChange' // chỉ thực thi khi đường dẫn hoặc truy vấn trong route thay đổi
  }
];
```
> Hàm dùng cho `resolver` cũng có thể dùng cho `title` (set title cho trang)

### 3.8. Bảo vệ tuyến đường (Route Guards)
Route Guards là các dịch vụ đặc biệt trong Angular Router được sử dụng để kiểm soát việc truy cập vào các tuyến đường (routes) dựa trên các điều kiện nhất định. Chúng giúp bảo vệ các tuyến đường khỏi việc truy cập trái phép hoặc không mong muốn.

Bảo vệ route bao gồm 2 loại:
- Bảo vệ truy cập vào route (canMatch - nên dùng, canActivate - ít dùng hơn)
- Bảo vệ rời khỏi route (canDeactivate)

#### 3.8.1. Bảo vệ truy cập trang (canMatch)
Bảo vệ truy cập trang (canMatch) cho phép bạn kiểm soát việc truy cập vào một route dựa trên các điều kiện nhất định. Nếu điều kiện không được thỏa mãn, người dùng sẽ không thể truy cập vào route đó.

Để sử dụng tính năng này trên route, bạn thêm thuộc tính `canMatch` vào định nghĩa route, tham số truyền vào canMatch là 1 `array` chứa các hàm, hoặc class xử lý.

VD:
```ts
const canAccessPage: CanMatchFn = (route: Route, segments: UrlSegment[]) => {
  const router = inject(Router);
  const rand = Math.random();
  if (rand < 0.5) {
    return true; // Cho phép truy cập
  }
  return new RedirectCommand(router.parseUrl("/unauthorized")); // Chuyển hướng đến trang khác nếu không đủ quyền truy cập
};

//...
{
  path: 'admin',
  canMatch: [canAccessPage]
}
```

Hoặc sử dụng class:
```ts
@Injectable({ providedIn: 'root' })
class CanMatchTeamSection implements CanMatch {
  constructor(private router: Router) {}
  canMatch(route: Route, segments: UrlSegment[]) {
    const shouldGetAccess = Math.random();
    if (shouldGetAccess < 0.5) {
      return true;
    }
    return new RedirectCommand(this.router.parseUrl('/unauthorized'));
  }
}
```

#### 3.8.2. Bảo vệ rời khỏi trang (canDeactivate)
Bảo vệ rời khỏi trang (canDeactivate) cho phép bạn kiểm soát việc rời khỏi một route dựa trên các điều kiện nhất định. Nếu điều kiện không được thỏa mãn, người dùng sẽ không thể rời khỏi route đó.

Để sử dụng tính năng này trên route, bạn thêm thuộc tính `canDeactivate` vào định nghĩa route, tham số truyền vào canDeactivate là 1 `array` chứa các hàm, hoặc class xử lý.

VD:
```ts
const canDeactivatePage: CanDeactivateFn<YourComponent> = (component: YourComponent) => {
  return component.isLeave ? window.confirm('Are you sure you want to leave this page?') : true;
};

//...
{
  path: 'your-path',
  canDeactivate: [canDeactivatePage]
}
```

Hoặc sử dụng class:
```ts
@Injectable({ providedIn: 'root' })
class CanDeactivateYourComponent implements CanDeactivate<YourComponent> {
  canDeactivate(component: YourComponent): Observable<boolean> | Promise<boolean> | boolean {
    return component.canDeactivate ? component.canDeactivate() : true;
  }
}
```

Trong đó `<YourComponent>` là component mà bạn muốn bảo vệ khi người dùng cố gắng rời khỏi trang.

#### 3.8.3. Reload lại trang bằng Router Angular, cấu hình điều hướng trong logic code.
Nhiều khi bạn muốn xóa 1 thứ gì đó, hoặc tác động lên trang và muốn trang reload lại để hiển thị dữ liệu mới và giữ lại thông tin query params trên URL. Đầu tiên bạn cần thêm thuộc tính `runGuardsAndResolvers: 'always'` vào route. Sau đó trong code bạn xử lý như sau:
```ts
import { Component, inject, input } from "@angular/core";
import { DatePipe } from "@angular/common";

import { type Task } from "./task.model";
import { CardComponent } from "../../shared/card/card.component";
import { TasksService } from "../tasks.service";
import { ActivatedRoute, Router } from "@angular/router";

@Component({
  selector: "app-task",
  standalone: true,
  templateUrl: "./task.component.html",
  styleUrl: "./task.component.css",
  imports: [DatePipe, CardComponent],
})
export class TaskComponent {
  task = input.required<Task>();
  private tasksService = inject(TasksService);
  router = inject(Router);
  activatedRoute = inject(ActivatedRoute);

  onComplete() {
    this.tasksService.removeTask(this.task().id);
    this.router.navigate(["./"], {
      // Điều hướng đến route hiện tại
      relativeTo: this.activatedRoute, // Tương đối với route hiện tại
      onSameUrlNavigation: "reload", // Tải lại trang nếu cùng URL
      queryParamsHandling: "preserve", // Giữ nguyên các tham số truy vấn
    });
  }
}

```

### 3.9. Lazy Loading với `loadComponent` và `loadChildren`
#### 3.9.1. So sánh `loadComponent` và `loadChildren`

- `loadComponent`: Tải một thành phần cụ thể khi cần thiết. Thích hợp cho các thành phần độc lập, không phụ thuộc vào các thành phần khác (standalone)
- `loadChildren`: Tải một module con (child module) cùng với tất cả các thành phần, dịch vụ và các tài nguyên khác của nó. Thích hợp cho việc chia nhỏ ứng dụng thành các module lớn hơn, giúp cải thiện hiệu suất và khả năng bảo trì. (module)
- `loadChildren` Cũng có thể được sử dụng để tải các route con (child routes)

#### 3.9.2. Ví dụ sử dụng `loadComponent` và `loadChildren`
```ts
import { loadComponent } from '@angular/core';

const routes: Routes = [
  {
    path: 'lazy',
    loadComponent: () => import('./lazy/lazy.component').then(m => m.LazyComponent)
  }
];
```

```ts
import { loadChildren } from '@angular/core';

const routes: Routes = [
  {
    path: 'admin',
    loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule)
  }
];
```

```ts
import { Routes } from '@angular/router';

export const routes: Routes = [
  {
    path: 'admin',
    component: AdminComponent
  }
];

/// ...

import { loadChildren } from '@angular/core';

const routes: Routes = [
  {
    path: '',
    loadChildren: () => import('./admin/admin.route').then(m => m.routes)
  }
];
```

> Lưu ý: Khi sử dụng `Route Lazy Loading`, bạn cần đảm bảo rằng các `service` được cung cấp trong module cha (parent module) hoặc trong module con (child module) được tải đúng cách. Điều này đảm bảo rằng các `service` này có thể được sử dụng trong các thành phần (components) của module con mà không gặp phải lỗi. Để làm điều đó, bạn cần thêm thuộc tính `providers` để tải trước các `service` này trong module con.
```ts
//...
{
  path: 'admin',
  providers: [AdminService],
  loadChildren: () => import('./admin/admin.route').then(m => m.routes)
}
```

#### 3.9.3. Lazy với `defer`
`defer` là một toán tử sử dụng trong template để trì hoãn việc thực thi cho đến khi 1 điều kiện nào đó được thỏa mãn. Trong trường hợp này, nó được sử dụng để trì hoãn việc render UI cho đến khi các dữ liệu cần thiết được tải xong.

Các trigger thường sử dụng với `defer` bao gồm
- `on idle`: Khi trình duyệt không bận rộn với các tác vụ khác, `defer` sẽ cho phép các tác vụ được trì hoãn cho đến khi trình duyệt sẵn sàng xử lý chúng.
- `on viewport`: Khi phần tử nằm trong viewport (khu vực nhìn thấy được của trình duyệt), `defer` sẽ cho phép các tác vụ được thực thi.
- `on interaction`: Khi người dùng tương tác với trang (ví dụ: cuộn, nhấp chuột), `defer` sẽ cho phép các tác vụ được thực thi.
- `on hover`: Khi người dùng di chuột qua phần tử, `defer` sẽ cho phép các tác vụ được thực thi.
- `on immediate`: Khi người dùng thực hiện một hành động ngay lập tức (ví dụ: nhấp chuột), `defer` sẽ cho phép các tác vụ được thực thi.
- `on timer`: Khi một bộ đếm thời gian (timer) hết hạn, `defer` sẽ cho phép các tác vụ được thực thi.
- `prefetch on hover`: Khi người dùng di chuột qua phần tử, lazy loading sẽ được kích hoạt để tải trước nội dung.

`defer` sẽ sử dụng đi kèm với `placeholder` để hiển thị một nội dung tạm thời trong khi chờ đợi các tác vụ được thực thi. Các trigger này có thể sử dụng cùng 1 lúc, ngăn cách bằng dấu chấm phẩy `;`

```html
@defer (on viewport; on timer(5s)) { <!-- Chỉ hiển thị khi phần tử nằm trong viewport hoặc sau 5 giây -->
  <app-data />
} @placeholder {
  <img src="loading.gif" alt="Loading..." /> <!-- Hiển thị placeholder trong khi chờ tải -->
}
```

## 4. Router events, TitleStrategy và SEO
- **Router events**: Lắng nghe `NavigationStart`, `NavigationEnd`, `NavigationCancel`, `NavigationError` để điều khiển loading indicator hoặc log sự cố.
```ts
this.router.events
  .pipe(filter(event => event instanceof NavigationStart))
  .subscribe(() => this.isNavigating = true);
```
- **`TitleStrategy`**: Angular 15+ cho phép bạn tùy biến tiêu đề trang dựa trên dữ liệu route.
```ts
@Injectable({ providedIn: 'root' })
class CustomTitleStrategy extends TitleStrategy {
  constructor(private readonly title: Title) {
    super();
  }
  override updateTitle(snapshot: RouterStateSnapshot) {
    const title = this.buildTitle(snapshot);
    if (title) {
      this.title.setTitle(`${title} | Angular Getting Started`);
    }
  }
}
```
Trong `bootstrapApplication`: `providers: [{ provide: TitleStrategy, useClass: CustomTitleStrategy }]`.
- **Meta tags**: Sử dụng `Meta` service cập nhật `description`, `og:image` trong `resolve` hoặc component. Khi triển khai SSR (tham khảo `11.Configuration.md`), điều này rất quan trọng cho SEO.

## 5. Preloading & chiến lược tải dữ liệu
- **PreloadAllModules**: Tải các module lazy ngay sau khi app idle, giúp người dùng truy cập nhanh hơn lần sau.
```ts
provideRouter(routes, withPreloading(PreloadAllModules));
```
- **CustomPreloadingStrategy**: Tạo class dựa trên `Route.data.preload` để chỉ preload những route gắn cờ.
```ts
export class SelectivePreloading implements PreloadingStrategy {
  preload(route: Route, load: () => Observable<any>): Observable<any> {
    return route.data?.['preload'] ? load() : of(null);
  }
}
```
- **Resolver song song**: Bạn có thể khai báo nhiều `resolve` trong một route. Sử dụng `resolve: { project: projectResolver, members: membersResolver }` để component nhận đủ dữ liệu trước khi render.

## 6. Named outlets và điều hướng song song
- Named outlet cho phép hiển thị nhiều nội dung độc lập trên cùng một trang (ví dụ mở bảng điều khiển, hộp thoại).
```html
<router-outlet name="sidebar" />
<router-outlet /> <!-- outlet chính -->
```
Khai báo route:
```ts
const routes: Routes = [
  { path: 'tickets', component: TicketsPageComponent },
  { path: 'tickets/:id', component: TicketsPageComponent, outlet: 'sidebar' },
];
```
Điều hướng:
```ts
this.router.navigate([{ outlets: { primary: ['tickets'], sidebar: ['tickets', 42] } }]);
```
- Auxiliary routes rất hữu ích khi bạn muốn giữ URL đồng bộ với trạng thái giao diện (ví dụ `/inbox(message/123)`).

## 7. SSR, hydration và điều hướng an toàn
- Khi bật SSR/SSG (`ng add @angular/ssr`), Angular Router sẽ xử lý điều hướng cả trên server và client. Hãy sử dụng `provideClientHydration()` và đảm bảo mọi navigation logic chạy trong `isPlatformBrowser` nếu phụ thuộc DOM.
- Sử dụng `routerLink` thay vì `href` để Angular có thể kết hợp lịch sử SPA với hydrate state từ server.
- Nếu cần gọi API trước khi hydration hoàn tất, đặt logic trong `transferState` hoặc resolver để server render sẵn dữ liệu, sau đó client đọc lại mà không cần request lặp.
- Đối với ứng dụng đa ngôn ngữ, có thể định nghĩa prefix `/vi`, `/en` trong router hoặc dùng `i18nRouter` (tham khảo hướng dẫn chi tiết ở `11.Configuration.md`) để chuyển hướng dựa trên locale ngay khi người dùng truy cập.
