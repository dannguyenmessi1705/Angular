# Routing
## 1. Giới thiệu
- Routing trong Angular cho phép điều hướng giữa các thành phần khác nhau trong ứng dụng. Nó giúp quản lý các URL và hiển thị các thành phần tương ứng dựa trên URL hiện tại.
- Angular Router là một module mạnh mẽ cho phép bạn định nghĩa các tuyến đường (routes) trong ứng dụng của mình.
- Trong Angular nhờ routing có thể xây dựng các ứng dụng một trang (Single Page Applications - SPA) và ứng dụng đa trang (Multi-Page Applications - MPA).

## 2. Cấu hình Routing cơ bản

Để cấu hình routing trong Angular, bạn cần định nghĩa các tuyến đường (routes) trong ứng dụng của mình. Các tuyến đường này sẽ ánh xạ các URL đến các thành phần tương ứng.

### 2.1. Định nghĩa Routes

Trong Angular, bạn có thể định nghĩa các routes trong một file riêng biệt, thường là `app.routes.ts`. Dưới đây là một ví dụ về cách định nghĩa các routes:

```typescript
import { Routes } from "@angular/router";
import { TaskComponent } from "./tasks/task/task.component";
import { NoTaskComponent } from "./tasks/no-task/no-task.component";

export const routes: Routes = [
  {
    path: "", // <domain>/
    component: NoTaskComponent,
  },
  {
    path: "tasks", // <domain>/tasks
    component: TaskComponent,
  },
  {
    path: "**",
    component: ErrorComponent
  }
];
```
> Nên định nghĩa một component ErrorComponent để hiển thị thông báo lỗi khi không tìm thấy route ở cuối cùng (mức ưu tiên thấp nhất)

### 2.2. Cấu hình Config cho `main.ts`

Sau khi định nghĩa các routes, bạn cần cấu hình bật Router rồi import vào trong `providers` bằng cách tạo `app.config.ts`:

```typescript
import { provideRouter } from "@angular/router";
import { ApplicationConfig } from "@angular/core";
import { routes } from "./app.routes";

export const appConfig: ApplicationConfig = {
  providers: [
    provideRouter(routes) // Cấu hình Router, cho phép điều hướng giữa các thành phần
  ],
};
```
Sau đó thêm cấu hình vào trong `main.ts`:

```typescript
import { bootstrapApplication } from "@angular/platform-browser";

import { AppComponent } from "./app/app.component";
import { appConfig } from "./app/app.config";

bootstrapApplication(AppComponent, appConfig).catch((err) =>
  console.error(err)
);

```

### 2.3. Sử dụng `<router-outlet>`
Router Outlet là một chỉ thị trong Angular cho phép bạn hiển thị các thành phần tương ứng với các tuyến đường đã định nghĩa. Để sử dụng Router Outlet, bạn cần thêm nó vào trong template của thành phần cha.

Ví dụ: `app.component.html`

```html
<app-header />

<main>
  <app-users />

  <div>
    <router-outlet />
  </div>
</main>

```

Sau đó import `RouterOutlet` vào trong `component` đang sử dụng
```ts
import { Component } from '@angular/core';

import { HeaderComponent } from './header/header.component';
import { UsersComponent } from './users/users.component';
import { RouterOutlet } from '@angular/router';

@Component({
  selector: 'app-root',
  standalone: true,
  templateUrl: './app.component.html',
  styleUrl: './app.component.css',
  imports: [HeaderComponent, UsersComponent, RouterOutlet],
})
export class AppComponent {}
```

> Khi người dùng điều hướng đến một tuyến đường cụ thể, Angular sẽ tự động thay thế nội dung của Router Outlet bằng thành phần tương ứng với tuyến đường đó. (Chỉ hiển thị một thành phần `Router Outlet` tại một thời điểm, còn tất cả các thẻ khác không phải `Router Outlet` vẫn sẽ được giữ nguyên).


## 3. Routing nâng cao
### 3.1. Điều hướng giữa các thành phần
Thông thường thẻ `a` sẽ được sử dụng để điều hướng giữa các thành phần trong web bằng thuộc tính `href`. Tuy nhiên nó sẽ làm web bị tải lại toàn bộ trang và sẽ mất đi trạng thái của ứng dụng. Vì thế trong Angular, bạn có thể sử dụng thuộc tính `routerLink` để chỉ định tuyến đường mà bạn muốn điều hướng đến mà không làm mất đi trạng thái của ứng dụng.
Ví dụ:

```html
<a routerLink="/tasks">Đi đến trang Tasks</a>
```

Sau đó, trong `component` của template này, ta import thêm `RouterLink` vào trong `component` đang sử dụng
```ts
import { Component } from '@angular/core';

import { HeaderComponent } from './header/header.component';
import { UsersComponent } from './users/users.component';
import { RouterLink } from '@angular/router';

@Component({
  selector: 'app-root',
  standalone: true,
  templateUrl: './app.component.html',
  styleUrl: './app.component.css',
  imports: [HeaderComponent, UsersComponent, RouterLink],
})
export class AppComponent {}

```

> Khi người dùng nhấp vào liên kết này, Angular sẽ điều hướng đến tuyến đường `/tasks` và hiển thị thành phần tương ứng với tuyến đường đó trong Router Outlet.

Ngoài ra Angular còn cung cấp thêm class styles cho các đường link được active nhờ sử dụng `routerLinkActive`.
```html
<a routerLink="/tasks" routerLinkActive="selected">Đi đến trang Tasks</a>
```
Sau đó thêm `RouterLinkActive` vào phần `imports` của `Component`.

> Có thể truyền vào `routerLink` một mảng các tham số, sau đó Angular sẽ tự động ghép chúng lại thành một đường dẫn ngăn cách bằng dấu `/`. (Ví dụ: `[routerLink]="['/tasks', task().id]"` sẽ tạo thành đường dẫn `/tasks/1` nếu `task().id` là `1`) hoặc `[routerLink]="'/tasks/' + task().id"` hoặc `routerLink="{{'/tasks/' + task().id}}"`.

### 3.2. Điều hướng tới các route động (Dynamic Routing)
Dynamic Routing cho phép bạn định nghĩa các tuyến đường với các tham số động. Điều này rất hữu ích khi bạn cần hiển thị nội dung khác nhau dựa trên các tham số trong URL.

Ví dụ: Giả sử bạn có một trang chi tiết cho từng tác vụ và bạn muốn điều hướng đến trang đó với ID của tác vụ. Bạn có thể định nghĩa một tuyến đường như sau:

```ts
const routes: Routes = [
  {
    path: 'tasks/:id',
    component: TaskDetailComponent
  }
];
```
> `:id` là một tham số động (paramete của đường dẫn)

Trong ví dụ này, `:id` là một tham số động. Khi người dùng điều hướng đến `/tasks/1`, Angular sẽ hiển thị `TaskDetailComponent` và bạn có thể truy cập ID của tác vụ thông qua `ActivatedRoute`.

#### 3.2.1. Truy cập tham số động trong component với Input

Để truy cập tham số động trong component, bạn có thể sử dụng `withComponentInputBinding()` làm đối số thứ hai của `provideRouter` trong list provider của bạn. `withComponentInputBinding()` cho phép bạn ánh xạ các tham số route thành các thuộc tính đầu vào của component (bao gồm `dynamicRoute`, `data`, `title`, `resolver`,..). Ví dụ

```ts
import { provideRouter, withComponentInputBinding } from "@angular/router";
import { ApplicationConfig } from "@angular/core";
import { routes } from "./app.routes";

export const appConfig: ApplicationConfig = {
  providers: [provideRouter(routes, withComponentInputBinding())],
};
```

Sau đó sử dụng `input` trong component của bạn để nhận giá trị của tham số động. Với điều kiện là biến đặt tên giống với tên tham số trong route và phải thêm điều kiện là bắt buộc `input.required`.

```ts
import {
  Component,
  computed,
  DestroyRef,
  inject,
  Input,
  input,
  OnInit,
} from "@angular/core";
import { UsersService } from "../users.service";
import { ActivatedRoute } from "@angular/router";

@Component({
  selector: "app-user-tasks",
  standalone: true,
  templateUrl: "./user-tasks.component.html",
  styleUrl: "./user-tasks.component.css",
})
export class UserTasksComponent implements OnInit {
  private userService = inject(UsersService);
  userId = input.required<string>();
  username = computed(
    () => this.userService.users.find((u) => u.id === this.userId()?.name
  );
}

```

#### 3.2.2. Truy cập tham số động bằng Observable

Để truy cập tham số động bằng Observable, bạn có thể sử dụng `ActivatedRoute` để lấy thông tin về route hiện tại. Và không cần phải thêm tham số thứ 2 là `withComponentInputBinding()` vào `provideRouter`.

```ts
import {
  Component,
  computed,
  DestroyRef,
  inject,
  Input,
  input,
  OnInit,
} from "@angular/core";
import { UsersService } from "../users.service";
import { ActivatedRoute } from "@angular/router";

@Component({
  selector: "app-user-tasks",
  standalone: true,
  templateUrl: "./user-tasks.component.html",
  styleUrl: "./user-tasks.component.css",
})
export class UserTasksComponent implements OnInit {
  private userService = inject(UsersService);

  username: string = "";
  private destroyRef = inject(DestroyRef);
  private activatedRoute = inject(ActivatedRoute);

  ngOnInit(): void {
    console.log(this.activatedRoute);
    const sub = this.activatedRoute.params.subscribe({
      next: (params) => {
        this.username =
          this.userService.users.find((u) => u.id === params["userId"])?.name ??
          "";
      },
    });
    this.destroyRef.onDestroy(() => sub.unsubscribe());
  }
}

```

### 3.3. Nested Routes (Child Routes)
Nested Routes (Child Routes) cho phép bạn định nghĩa các tuyến đường con bên trong một tuyến đường cha. Điều này rất hữu ích khi bạn muốn tổ chức các thành phần của mình theo cấu trúc phân cấp.

Chỉ cần thêm thuộc tính `children` vào đối tượng route cha và định nghĩa các tuyến đường con bên trong mảng `children` như cách định nghĩa các tuyến đường thông thường route cha.

VD: Tạo 1 route như sau `/users/:userId/tasks` để hiển thị các nhiệm vụ của người dùng cụ thể.

```ts
import { Routes } from "@angular/router";
import { UserTasksComponent } from "./users/user-tasks/user-tasks.component";

const routes: Routes = [
  {
    path: "users/:userId",
    component: UserTasksComponent,
    children: [
      {
        path: "tasks",
        component: TasksComponent,
      },
    ],
  },
];
```

Sau đó imports `RouterOutlet` vào component cha và sử dụng `<router-outlet></router-outlet>` trong template của component cha để hiển thị các thành phần trang con.

> Lưu ý: Trong các route con, việc đọc các params từ url của route cha không thể thực hiện bằng mỗi `ActivatedRoute` hay `withComponentInputBinding()` được. Để sử dụng, chúng ta thêm tham số thứ 3 vào trong `provideRouter`. Đó chính là `withRouterConfig`

```ts
import {
  provideRouter,
  withComponentInputBinding,
  withRouterConfig,
} from "@angular/router";
import { ApplicationConfig } from "@angular/core";
import { routes } from "./app.routes";

export const appConfig: ApplicationConfig = {
  providers: [
    provideRouter(
      routes,
      withComponentInputBinding(),
      withRouterConfig({
        paramsInheritanceStrategy: "always", // Cho phép kế thừa tham số từ route cha
      })
    ),
  ],
};
```

### 3.4. Đường dẫn tương đối - tuyệt đối
Đường dẫn tương đối (relative path) là đường dẫn được xác định dựa trên vị trí hiện tại của route. Trong khi đó, đường dẫn tuyệt đối (absolute path) là đường dẫn bắt đầu từ gốc của ứng dụng.

Ví dụ:

- Đường dẫn tương đối: `tasks/new` (không có dấu `/` ở đầu => nó sẽ xác định bằng `đường dẫn hiện tại` + `/tasks/new`)
- Đường dẫn tuyệt đối: `/users/:userId/tasks/new` (bắt đầu bằng dấu `/`, xác định từ gốc ứng dụng)

> Lưu ý đối với các `dynamic route`: Khi sử dụng đường dẫn tuyệt đối, việc xác định các tham số động (như `:userId`) là khó, 1 cách để bỏ qua điều này là sử dụng dấu `...` để chỉ định các tham số động. VD: `/users/.../tasks/new`

### 3.5. Lazy Loading với `loadComponent` và `loadChildren`
#### 3.5.1. So sánh `loadComponent` và `loadChildren`

- `loadComponent`: Tải một thành phần cụ thể khi cần thiết. Thích hợp cho các thành phần độc lập, không phụ thuộc vào các thành phần khác (standalone)
- `loadChildren`: Tải một module con (child module) cùng với tất cả các thành phần, dịch vụ và các tài nguyên khác của nó. Thích hợp cho việc chia nhỏ ứng dụng thành các module lớn hơn, giúp cải thiện hiệu suất và khả năng bảo trì. (module)

#### 3.5.2. Ví dụ sử dụng `loadComponent` và `loadChildren`
```ts
import { loadComponent } from '@angular/core';

const routes: Routes = [
  {
    path: 'lazy',
    loadComponent: () => import('./lazy/lazy.component').then(m => m.LazyComponent)
  }
];
```

```ts
import { loadChildren } from '@angular/core';

const routes: Routes = [
  {
    path: 'admin',
    loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule)
  }
];
```
