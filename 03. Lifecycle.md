# Lifecycle trong Angular
## 1. Giới thiệu về Lifecycle Hooks
- Lifecycle Hooks là các phương thức cho phép bạn "hook" vào các giai đoạn khác nhau trong vòng đời của một component hoặc directive.
- Angular cung cấp một số lifecycle hooks mà bạn có thể sử dụng để thực hiện các hành động cụ thể tại các thời điểm khác nhau trong vòng đời của component.
- Quy trình, luồng hoạt động của các lifecycle hooks diễn ra như sau:
1. Constructor: Được gọi khi một instance của component được tạo ra.
2. ngOnChanges: Được gọi khi có sự thay đổi trong các thuộc tính đầu vào của component.
3. ngOnInit: Được gọi sau khi Angular khởi tạo tất cả các thuộc tính của component.
4. ngDoCheck: Được gọi trong mỗi vòng lặp phát hiện thay đổi.
5a. ngAfterContentInit: Được gọi sau khi nội dung của component đã được khởi tạo.
5b. ngAfterViewInit: Được gọi sau khi view của component đã được khởi tạo.
6a. ngAfterContentChecked: Được gọi sau khi nội dung của component đã được kiểm tra.
6b. ngAfterViewChecked: Được gọi sau khi view của component đã được kiểm tra.
7. afterRender: Được gọi sau khi component đã được render.

## 2. Các lifecycle phổ biến và tác dụng
### 2.1. Constructor
- Được gọi khi một instance của component được tạo ra. Đây là nơi bạn có thể thực hiện các khởi tạo cần thiết cho component.
- Bạn có thể sử dụng constructor để tiêm các phụ thuộc (dependencies) vào component.
### 2.2. ngOnChanges
- Được gọi khi có sự thay đổi trong các thuộc tính đầu vào của component. Đây là nơi bạn có thể thực hiện các hành động cần thiết khi có sự thay đổi dữ liệu.
- Bạn có thể sử dụng ngOnChanges để cập nhật lại dữ liệu trong component khi có sự thay đổi từ bên ngoài.
### 2.3. ngOnInit
- Được gọi sau khi Angular khởi tạo tất cả các thuộc tính của component. Đây là nơi bạn có thể thực hiện các khởi tạo cần thiết cho component.
- Khác với constructor, ngOnInit được gọi sau khi Angular đã thiết lập các thuộc tính đầu vào của component.
- Khác với ngOnChanges, ngOnInit chỉ được gọi một lần trong vòng đời của component.
>  Nên implement class Component với interface OnInit để tránh viết sai hàm `ngOnInit()`.
Ví dụ: Bạn có thể sử dụng ngOnInit để gọi một API và lấy dữ liệu cho component.
```ts
import { Component, OnInit } from "@angular/core";
import { HttpClient } from "@angular/common/http";

@Component({
  selector: "app-example",
  templateUrl: "./example.component.html",
  styleUrls: ["./example.component.css"],
})
export class ExampleComponent implements OnInit {
  data: any;

  constructor(private http: HttpClient) {}

  ngOnInit() {
    this.http.get("https://api.example.com/data").subscribe((response) => {
      this.data = response;
    });
  }
}
```

### 2.4. ngDoCheck
- Được gọi trong mỗi vòng lặp phát hiện thay đổi. Đây là nơi bạn có thể thực hiện các kiểm tra tùy chỉnh để phát hiện sự thay đổi trong dữ liệu.
- Bạn có thể sử dụng ngDoCheck để so sánh các giá trị trước và sau khi thay đổi, từ đó thực hiện các hành động cần thiết.
- Nguyên tắc hoạt động của ngDoCheck là Angular sẽ gọi phương thức này trong mỗi vòng lặp phát hiện thay đổi, cho phép bạn kiểm tra và xử lý các thay đổi một cách linh hoạt.

### 2.5a. ngAfterContentInit
- Được gọi sau khi nội dung của component đã được khởi tạo. Nội dung ở đây đề cập đến các phần tử con được truyền vào component qua `ng-content`.
- Bạn có thể sử dụng ngAfterContentInit để thực hiện các thao tác cần thiết với nội dung của component.

### 2.5b. ngAfterViewInit
- Được gọi sau khi view của component đã được khởi tạo. Đây là nơi bạn có thể thực hiện các hành động cần thiết sau khi view đã sẵn sàng. View ở đây đề cập đến template của component.
- Bạn có thể sử dụng ngAfterViewInit để thực hiện các thao tác cần thiết với view của component.

### 2.6a. ngAfterContentChecked
- Được gọi sau khi nội dung của component đã được kiểm tra. Ý là các phần tử con được truyền vào component qua `ng-content` đã được kiểm tra. Kiểm tra ở đây đề cập đến việc Angular đã kiểm tra và cập nhật nội dung của component.
- Bạn có thể sử dụng ngAfterContentChecked để thực hiện các thao tác cần thiết với nội dung của component.

### 2.6b. ngAfterViewChecked
- Được gọi sau khi view của component đã được kiểm tra. Ý là template của component đã được kiểm tra. Kiểm tra ở đây đề cập đến việc Angular đã kiểm tra và cập nhật view của component.
- Bạn có thể sử dụng ngAfterViewChecked để thực hiện các thao tác cần thiết với view của component.

### 2.7. afterRender
- Được gọi sau khi component đã được render. Đây là nơi bạn có thể thực hiện các hành động cần thiết sau khi component đã được hiển thị trên màn hình.
- Bạn có thể sử dụng afterRender để thực hiện các thao tác cần thiết với component sau khi nó đã được render.
> Khác với các hook khác, afterRender tương thích với Angular 16 trở lên, chưa có hàm implement mà phải thực thi trong hàm `constructor()`
```ts
import { afterRender } from "@angular/core";

@Component({
  selector: "app-example",
  templateUrl: "./example.component.html",
  styleUrls: ["./example.component.css"],
})
export class ExampleComponent {
  constructor() {
      afterRender(() => {
        console.log("Component has been rendered");
      })
  }
}
```

### 2.8. afterNextRender
- Được gọi sau khi component đã được render lần tiếp theo. Đây là nơi bạn có thể thực hiện các hành động cần thiết sau khi component đã được hiển thị trên màn hình lần tiếp theo.
- Bạn có thể sử dụng afterNextRender để thực hiện các thao tác cần thiết với component sau khi nó đã được render lần tiếp theo.
> Khác với các hook khác, afterNextRender tương thích với Angular 16 trở lên, chưa có hàm implement mà phải thực thi trong hàm `constructor()`
```ts
import { afterNextRender } from "@angular/core";

@Component({
  selector: "app-example",
  templateUrl: "./example.component.html",
  styleUrls: ["./example.component.css"],
})
export class ExampleComponent {
  constructor() {
      afterNextRender(() => {
        console.log("Component has been rendered next");
      });
  }
}
```

So sánh `afterRender` và `afterNextRender`:
- `afterRender` được gọi sau khi component được render (Bất kỳ phần tử nào được render, không cần nằm trong component của nó) => Có thể được gọi nhiều lần trong vòng đời của component.
- `afterNextRender` được gọi sau khi component đã được render lần tiếp theo. 

### 2.9. ngOnDestroy
- Được gọi trước khi component bị hủy. Đây là nơi bạn có thể thực hiện các hành động cần thiết để dọn dẹp tài nguyên, hủy đăng ký các dịch vụ, hoặc thực hiện các thao tác khác trước khi component bị xóa.
- Bạn có thể sử dụng ngOnDestroy để hủy đăng ký các Observable, hoặc thực hiện các thao tác dọn dẹp khác.
- Có 2 cách để thực hiện ngOnDestroy:
  1. Sử dụng phương thức ngOnDestroy trong component.
  2. Sử dụng toán tử `DestroyRef` (từ v16 trở đi).

> `DestroyRef` là một service giúp tự động hủy các subscription khi component bị hủy.

#### 2.8.1. Sử dụng phương thức ngOnDestroy
```ts
import { Component, OnDestroy } from "@angular/core";

@Component({
  selector: "app-example",
  templateUrl: "./example.component.html",
  styleUrls: ["./example.component.css"],
})
export class ExampleComponent implements OnDestroy {
  private interval: ReturnType<typeof setInterval>;

  constructor() {
    this.interval = setInterval(() => {
      // Thực hiện các thao tác cần thiết ở đây
    }, 1000);
  }

  ngOnDestroy() {
    clearInterval(this.interval);
  } // trước khi component bị hủy
}
```

#### 2.8.2. Sử dụng `DestroyRef`
```ts
import { Component, DestroyRef, inject } from "@angular/core";

@Component({
  selector: "app-example",
  templateUrl: "./example.component.html",
  styleUrls: ["./example.component.css"],
})
export class ExampleComponent {

  private destroyRef = inject(DestroyRef); // Inject DestroyRef vào component

  constructor() {
    const interval = setInterval(() => {
      // Thực hiện các thao tác cần thiết ở đây
    }, 1000);

    this.destroyRef.onDestroy(() => {
      clearInterval(interval);
    }); // Hủy interval khi component bị hủy
  }

}
```