# Lifecycle trong Angular
## 1. Giới thiệu về Lifecycle Hooks
- Lifecycle Hooks là các phương thức cho phép bạn "hook" vào các giai đoạn khác nhau trong vòng đời của một component hoặc directive.
- Angular cung cấp một số lifecycle hooks mà bạn có thể sử dụng để thực hiện các hành động cụ thể tại các thời điểm khác nhau trong vòng đời của component.
- Quy trình, luồng hoạt động của các lifecycle hooks diễn ra như sau:
1. Constructor: Được gọi khi một instance của component được tạo ra.
2. ngOnChanges: Được gọi khi có sự thay đổi trong các thuộc tính đầu vào của component.
3. ngOnInit: Được gọi sau khi Angular khởi tạo tất cả các thuộc tính của component.
4. ngDoCheck: Được gọi trong mỗi vòng lặp phát hiện thay đổi.
5a. ngAfterContentInit: Được gọi sau khi nội dung của component đã được khởi tạo.
5b. ngAfterViewInit: Được gọi sau khi view của component đã được khởi tạo.
6a. ngAfterContentChecked: Được gọi sau khi nội dung của component đã được kiểm tra.
6b. ngAfterViewChecked: Được gọi sau khi view của component đã được kiểm tra.
7. afterRender: Được gọi sau khi component đã được render.

## 2. Các lifecycle phổ biến và tác dụng
### 2.1. Constructor
- Được gọi khi một instance của component được tạo ra. Đây là nơi bạn có thể thực hiện các khởi tạo cần thiết cho component.
- Bạn có thể sử dụng constructor để tiêm các phụ thuộc (dependencies) vào component.
### 2.2. ngOnChanges
- Được gọi khi có sự thay đổi trong các thuộc tính đầu vào của component. Đây là nơi bạn có thể thực hiện các hành động cần thiết khi có sự thay đổi dữ liệu.
- Bạn có thể sử dụng ngOnChanges để cập nhật lại dữ liệu trong component khi có sự thay đổi từ bên ngoài.
### 2.3. ngOnInit
- Được gọi sau khi Angular khởi tạo tất cả các thuộc tính của component. Đây là nơi bạn có thể thực hiện các khởi tạo cần thiết cho component.
- Khác với constructor, ngOnInit được gọi sau khi Angular đã thiết lập các thuộc tính đầu vào của component.
- Khác với ngOnChanges, ngOnInit chỉ được gọi một lần trong vòng đời của component.
>  Nên implement class Component với interface OnInit để tránh viết sai hàm `ngOnInit()`.
Ví dụ: Bạn có thể sử dụng ngOnInit để gọi một API và lấy dữ liệu cho component.
```ts
import { Component, OnInit } from "@angular/core";
import { HttpClient } from "@angular/common/http";

@Component({
  selector: "app-example",
  templateUrl: "./example.component.html",
  styleUrls: ["./example.component.css"],
})
export class ExampleComponent implements OnInit {
  data: any;

  constructor(private http: HttpClient) {}

  ngOnInit() {
    this.http.get("https://api.example.com/data").subscribe((response) => {
      this.data = response;
    });
  }
}
```

### 2.4. ngDoCheck
- Được gọi trong mỗi vòng lặp phát hiện thay đổi. Đây là nơi bạn có thể thực hiện các kiểm tra tùy chỉnh để phát hiện sự thay đổi trong dữ liệu.
- Bạn có thể sử dụng ngDoCheck để so sánh các giá trị trước và sau khi thay đổi, từ đó thực hiện các hành động cần thiết.
- Nguyên tắc hoạt động của ngDoCheck là Angular sẽ gọi phương thức này trong mỗi vòng lặp phát hiện thay đổi, cho phép bạn kiểm tra và xử lý các thay đổi một cách linh hoạt.

### 2.5a. ngAfterContentInit
- Được gọi sau khi nội dung của component đã được khởi tạo. Nội dung ở đây đề cập đến các phần tử con được truyền vào component qua `ng-content`.
- Bạn có thể sử dụng ngAfterContentInit để thực hiện các thao tác cần thiết với nội dung của component.

### 2.5b. ngAfterViewInit
- Được gọi sau khi view của component đã được khởi tạo. Đây là nơi bạn có thể thực hiện các hành động cần thiết sau khi view đã sẵn sàng. View ở đây đề cập đến template của component.
- Bạn có thể sử dụng ngAfterViewInit để thực hiện các thao tác cần thiết với view của component.

### 2.6a. ngAfterContentChecked
- Được gọi sau khi nội dung của component đã được kiểm tra. Ý là các phần tử con được truyền vào component qua `ng-content` đã được kiểm tra. Kiểm tra ở đây đề cập đến việc Angular đã kiểm tra và cập nhật nội dung của component.
- Bạn có thể sử dụng ngAfterContentChecked để thực hiện các thao tác cần thiết với nội dung của component.

### 2.6b. ngAfterViewChecked
- Được gọi sau khi view của component đã được kiểm tra. Ý là template của component đã được kiểm tra. Kiểm tra ở đây đề cập đến việc Angular đã kiểm tra và cập nhật view của component.
- Bạn có thể sử dụng ngAfterViewChecked để thực hiện các thao tác cần thiết với view của component.

### 2.7. afterRender
- Được gọi sau khi component đã được render. Đây là nơi bạn có thể thực hiện các hành động cần thiết sau khi component đã được hiển thị trên màn hình.
- Bạn có thể sử dụng afterRender để thực hiện các thao tác cần thiết với component sau khi nó đã được render.
> Khác với các hook khác, afterRender tương thích với Angular 16 trở lên, chưa có hàm implement mà phải thực thi trong hàm `constructor()`
```ts
import { afterRender } from "@angular/core";

@Component({
  selector: "app-example",
  templateUrl: "./example.component.html",
  styleUrls: ["./example.component.css"],
})
export class ExampleComponent {
  constructor() {
      afterRender(() => {
        console.log("Component has been rendered");
      })
  }
}
```

### 2.8. afterNextRender
- Được gọi sau khi component đã được render lần tiếp theo. Đây là nơi bạn có thể thực hiện các hành động cần thiết sau khi component đã được hiển thị trên màn hình lần tiếp theo.
- Bạn có thể sử dụng afterNextRender để thực hiện các thao tác cần thiết với component sau khi nó đã được render lần tiếp theo.
> Khác với các hook khác, afterNextRender tương thích với Angular 16 trở lên, chưa có hàm implement mà phải thực thi trong hàm `constructor()`
```ts
import { afterNextRender } from "@angular/core";

@Component({
  selector: "app-example",
  templateUrl: "./example.component.html",
  styleUrls: ["./example.component.css"],
})
export class ExampleComponent {
  constructor() {
      afterNextRender(() => {
        console.log("Component has been rendered next");
      });
  }
}
```

So sánh `afterRender` và `afterNextRender`:
- `afterRender` được gọi sau khi component được render (Bất kỳ phần tử nào được render, không cần nằm trong component của nó) => Có thể được gọi nhiều lần trong vòng đời của component.
- `afterNextRender` được gọi sau khi component đã được render lần tiếp theo. 

### 2.9. ngOnDestroy
- Được gọi trước khi component bị hủy. Đây là nơi bạn có thể thực hiện các hành động cần thiết để dọn dẹp tài nguyên, hủy đăng ký các dịch vụ, hoặc thực hiện các thao tác khác trước khi component bị xóa.
- Bạn có thể sử dụng ngOnDestroy để hủy đăng ký các Observable, hoặc thực hiện các thao tác dọn dẹp khác.
- Có 2 cách để thực hiện ngOnDestroy:
  1. Sử dụng phương thức ngOnDestroy trong component.
  2. Sử dụng toán tử `DestroyRef` (từ v16 trở đi).

> `DestroyRef` là một service giúp tự động hủy các subscription khi component bị hủy.

#### 2.8.1. Sử dụng phương thức ngOnDestroy
```ts
import { Component, OnDestroy } from "@angular/core";

@Component({
  selector: "app-example",
  templateUrl: "./example.component.html",
  styleUrls: ["./example.component.css"],
})
export class ExampleComponent implements OnDestroy {
  private interval: ReturnType<typeof setInterval>;

  constructor() {
    this.interval = setInterval(() => {
      // Thực hiện các thao tác cần thiết ở đây
    }, 1000);
  }

  ngOnDestroy() {
    clearInterval(this.interval);
  } // trước khi component bị hủy
}
```

#### 2.8.2. Sử dụng `DestroyRef`
```ts
import { Component, DestroyRef, inject } from "@angular/core";

@Component({
  selector: "app-example",
  templateUrl: "./example.component.html",
  styleUrls: ["./example.component.css"],
})
export class ExampleComponent {

  private destroyRef = inject(DestroyRef); // Inject DestroyRef vào component

  constructor() {
    const interval = setInterval(() => {
      // Thực hiện các thao tác cần thiết ở đây
    }, 1000);

    this.destroyRef.onDestroy(() => {
      clearInterval(interval);
    }); // Hủy interval khi component bị hủy
  }

}
```

## 3. Sử dụng signal với `effect`
- `effect` được sử dụng để theo dõi sự thay đổi của signal và thực hiện các hành động tương ứng khi signal thay đổi.
> Lưu ý `effect` chỉ hoạt động với signal và chỉ được sử dụng bên trong `constructor()`
> VD:
```ts
import { Component, OnInit, OnDestroy, signal, effect } from "@angular/core";

@Component({
  selector: "app-server-status",
  standalone: true,
  imports: [],
  templateUrl: "./server-status.component.html",
  styleUrl: "./server-status.component.css",
})
export class ServerStatusComponent implements OnInit, OnDestroy {
  currentStatus = signal<"online" | "offline" | "unknown">("online");
  private interval?: ReturnType<typeof setInterval>;

  constructor() {
    console.log("No change", this.currentStatus());

    effect(() => {
      console.log(
        "Status changed when signal change by effect:",
        this.currentStatus()
      );
    });
  }

  ngOnInit() {
    this.interval = setInterval(() => {
      const rnd = Math.random();
      if (rnd < 0.5) {
        this.currentStatus.set("online");
      } else if (rnd < 0.9) {
        this.currentStatus.set("offline");
      } else this.currentStatus.set("unknown");
    }, 1000);
  }

  ngAfterViewInit() {
    console.log("AFTER VIEW INIT");
  } // sau khi view đã được khởi tạo

  ngOnDestroy(): void {
    clearInterval(this.interval);
  }
}
```

## 4. Bảng tổng hợp lifecycle hooks
| Hook | Thời điểm kích hoạt | Ghi chú thực tế |
|------|--------------------|-----------------|
| `constructor` | Khi Angular tạo instance component/directive | Nên giữ logic nhẹ, chỉ inject phụ thuộc và khởi tạo biến. |
| `ngOnChanges` | Ngay khi giá trị `@Input` thay đổi (gọi trước `ngOnInit`) | Nhận tham số `SimpleChanges`, hữu ích để so sánh giá trị cũ/mới và tránh gọi API thừa. |
| `ngOnInit` | Sau khi Inputs được thiết lập | Gọi API, subscribe dữ liệu, khởi tạo Form/Signal tại đây để tránh phụ thuộc null. |
| `ngDoCheck` | Mỗi chu kỳ change detection | Ít dùng, chỉ nên áp dụng cho các kịch bản cần so sánh sâu (deep compare). |
| `ngAfterContentInit` | Sau khi nội dung truyền qua `ng-content` được render | Kết hợp với `@ContentChild` để đọc template của component con. |
| `ngAfterContentChecked` | Sau mỗi lần kiểm tra nội dung | Nếu cần đọc giá trị DOM, nên gắn cờ và xử lý trong `AfterView...` để tránh ExpressionChangedError. |
| `ngAfterViewInit` | Sau khi view và `@ViewChild` sẵn sàng | Gọi thư viện ngoài (chart, map) hoặc focus input. |
| `ngAfterViewChecked` | Sau mỗi lần view được kiểm tra | Không nên cập nhật state ở đây (dễ gây vòng lặp). |
| `ngOnDestroy` | Trước khi component bị hủy | Hủy subscription, timer, connection, observer. |
| `afterRender` / `afterNextRender` | Angular 17+ | Dùng cho kịch bản cần chạy sau mỗi lần render hoặc chỉ render tiếp theo. |

## 5. `afterRender` và `afterNextRender`
Hai helper mới trong Angular 17 giúp thay thế những `setTimeout(..., 0)` trước đây khi cần thao tác DOM ngay sau khi component render.
```ts
import { Component, afterRender, afterNextRender, DestroyRef, inject } from '@angular/core';

@Component({
  selector: 'app-dashboard',
  standalone: true,
  templateUrl: './dashboard.component.html',
})
export class DashboardComponent {
  private destroyRef = inject(DestroyRef);

  constructor() {
    afterRender(() => {
      console.log('Sau mỗi lần render');
    }, { injector: this.destroyRef });

    afterNextRender(() => {
      console.log('Chỉ gọi một lần ở render kế tiếp');
    }, { injector: this.destroyRef });
  }
}
```
> Truyền `DestroyRef` giúp Angular tự hủy callback khi component bị tháo ra khỏi DOM, tránh rò rỉ bộ nhớ.

## 6. Mẹo kiểm thử và gỡ lỗi vòng đời
- **Theo dõi `SimpleChange`**: Ghi log `changes['inputName']?.previousValue` và `currentValue` để hiểu vì sao component render lại nhiều lần. Trong unit test bạn có thể gọi `component.ngOnChanges({ inputName: new SimpleChange(...) })` để mô phỏng.
- **`takeUntilDestroyed()`**: Khi kết hợp lifecycle với RxJS, hãy dùng `takeUntilDestroyed()` thay vì tự giữ `DestroyRef`. Ví dụ: `source$.pipe(takeUntilDestroyed()).subscribe(...)` trong `ngOnInit`.
- **`ChangeDetectorRef`**: Nếu hook cập nhật dữ liệu nằm ngoài vùng change detection (ví dụ callback của thư viện bên ngoài), gọi `cdRef.detectChanges()` hoặc `markForCheck()` trong `ngAfterViewInit`/`ngAfterContentInit`.
- **Kiểm thử**: Trong TestBed, gọi `fixture.detectChanges()` sẽ chạy `ngOnInit` và các hook tiếp theo. Để kiểm thử `ngOnDestroy`, hãy gọi `fixture.destroy()` và xác nhận rằng subscription/timer được hủy bằng spy.
