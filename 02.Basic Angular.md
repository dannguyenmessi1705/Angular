# Các hoạt động cơ bản trong Angular
## 1. Cách hoạt động, cấu trúc conponent trong Angular
- **Component**: Là một phần của giao diện người dùng, bao gồm HTML, CSS và TypeScript. Mỗi component có thể được coi là một "khối xây dựng" của ứng dụng Angular.
- **Module**: Là một tập hợp các component, dịch vụ và các phần khác của ứng dụng. Mỗi ứng dụng Angular có ít nhất một module gốc (root module).
- **Template**: Là phần HTML của component, nơi bạn định nghĩa giao diện người dùng
- **Metadata**: Là thông tin bổ sung về component, được định nghĩa bằng decorator như `@Component`.
- **Data Binding**: Là cơ chế kết nối dữ liệu giữa component và template. Angular hỗ trợ nhiều loại data binding như interpolation, property binding, event binding và two-way binding.
- **Dependency Injection**: Là một mô hình thiết kế cho phép các component và dịch vụ nhận các phụ thuộc của chúng từ bên ngoài, giúp quản lý mã nguồn dễ dàng hơn.

### 1.1. Cấu trúc component
- **Selector**: Là tên của component được sử dụng trong template HTML. Ví dụ: `<app-root>`.
- **Template**: Là phần HTML của component, có thể được định nghĩa trực tiếp trong decorator `@Component` hoặc thông qua một file HTML riêng biệt.
- **Styles**: Là phần CSS của component, có thể được định nghĩa trực tiếp trong decorator `@Component` hoặc thông qua một file CSS riêng biệt.
- **Class**: Là phần TypeScript của component, nơi bạn định nghĩa logic và dữ liệu của component.
- **Decorator**: Là một hàm được sử dụng để thêm metadata cho class, ví dụ như `@Component`, `@Injectable`, v.v.

VD:
```typescript
import { Component } from '@angular/core';
@Component({
  selector: 'app-example', // Tên selector của component sẽ được sử dụng trong template HTML
  templateUrl: './example.component.html', // Đường dẫn đến file HTML của component
  styleUrls: ['./example.component.css'] // Đường dẫn đến file CSS của component
})
export class ExampleComponent {
}
```
```template
<h1>Welcome to {{ title }}!</h1>
<p>This is an example component.</p>
```
```css
h1 {
  color: blue;
}
p {
  font-size: 16px;
}
```

> Muốn import component vào component khác để template có thể sử dụng, bạn cần khai báo component đó trong component cha chứa component đó, đặt trong biến `imports` của decorator `@Component` hoặc trong module chứa component đó.
```typescript
import { Component } from '@angular/core';
import { ExampleComponent } from './example/example.component';
@Component({
    selector: 'app-root',
    templateUrl: './app.component.html',
    styleUrls: ['./app.component.css'],
    imports: [ExampleComponent] // Import component ExampleComponent để sử dụng trong template của component này
})
export class AppComponent {};
```

### 1.2. Cách truyền dữ liệu từ component vào template
- Các giá trị, biến được định nghĩa trong khai báo class của component sẽ được sử dụng trong template của component đó.
- Có các loại giá trị có thể truyền vào template:
  - **Biến**: Các biến được định nghĩa trong class của component. Trong template, bạn có thể sử dụng cú pháp `{{ variableName }}` để hiển thị giá trị của biến.
  - **Hàm get <tên-hàm>**: Các hàm được định nghĩa trong class của component, có thể được gọi trong template. Trong template, bạn có thể sử dụng cú pháp `{{ getFunctionName() }}` để gọi hàm và hiển thị giá trị trả về.
  - **Hàm on<tên-hàm>**: Các hàm được định nghĩa trong class của component, thường được sử dụng để xử lý sự kiện. Trong template, bạn có thể sử dụng cú pháp `(eventName)="onFunctionName()"` để gọi hàm khi sự kiện xảy ra.
- **Ví dụ**:
```typescript
import { Component } from '@angular/core';
@Component({
  selector: 'app-example',
  templateUrl: './example.component.html',
  styleUrls: ['./example.component.css']
})
export class ExampleComponent {
  title: string = 'Angular Example'; // Biến được sử dụng trong template
  count: number = 0; // Biến đếm

  getCount(): number { // Hàm get để lấy giá trị count
    return this.count;
  }

  onIncrement(): void { // Hàm xử lý sự kiện khi nút được nhấn
    this.count++;
  }
}
```
```template
<h1>{{ title }}</h1>
<p>Count: {{ getCount() }}</p>
<button (click)="onIncrement()">Increment</button>
```

- Ngoài ra, bạn có thể sử dụng các kỹ thuật data binding để liên kết dữ liệu giữa component và template:
    - **Event Binding**: Sử dụng dấu ngoặc đơn `()` để liên kết sự kiện của HTML với phương thức trong component.
    - **Two-Way Binding**: Sử dụng cú pháp `[(ngModel)]` để liên kết dữ liệu giữa component và template, cho phép cập nhật dữ liệu hai chiều.
    - **Attribute Binding**: Sử dụng cú pháp `[attr.attributeName]` để liên kết thuộc tính của HTML với giá trị trong component.
    - **Class Binding**: Sử dụng cú pháp `[class.className]` để liên kết class của HTML với giá trị trong component.
    - **Style Binding**: Sử dụng cú pháp `[style.styleName]` để liên kết style của HTML với giá trị trong component.
    - **Property Binding**: Sử dụng dấu ngoặc vuông `[]` để liên kết thuộc tính của HTML với giá trị trong component.
    - **Interpolation**: Sử dụng dấu ngoặc kép kép `{{ }}` để chèn giá trị từ component vào template.

### 1.3. Cách truyền dữ liệu từ template vào component
- Để truyền dữ liệu từ template vào component, bạn có thể sử dụng các kỹ thuật data binding như:
  - **Event Binding**: Sử dụng cú pháp `(eventName)="methodName($event)"` để gọi phương thức trong component khi sự kiện xảy ra, và truyền dữ liệu từ sự kiện vào phương thức.
  - **Two-Way Binding**: Sử dụng cú pháp `[(ngModel)]="property"` để liên kết dữ liệu hai chiều giữa template và component.
- **Ví dụ**:
```typescript
import { Component } from '@angular/core';
import { FormsModule } from '@angular/forms';
@Component({
  selector: 'app-example',
  templateUrl: './example.component.html',
  styleUrls: ['./example.component.css'],
  imports: [FormsModule] // Import FormsModule để sử dụng ngModel
})
export class ExampleComponent {
  name: string = ''; // Biến để lưu tên người dùng

  onSubmit(): void { // Hàm xử lý sự kiện khi form được submit
    console.log('Submitted name:', this.name);
  }
}
```
```template
<form (ngSubmit)="onSubmit()">
  <label for="name">Name:</label>
  <input type="text" id="name" [(ngModel)]="name" name="name"> <!-- Sử dụng ngModel để liên kết dữ liệu hai chiều -->
  <button type="submit">Submit</button>
</form>
```

### 1.4. Cách sử dụng các component con trong component cha
- Để sử dụng các component con trong component cha, bạn cần thực hiện các bước sau
  1. **Import Component Con**: Import component con vào component cha.
  2. **Khai báo trong Decorator**: Thêm component con vào mảng `imports` trong decorator `@Component` của component cha.
  3. **Sử dụng Selector**: Sử dụng selector của component con trong template của component cha. Selector có thể là một trong những loại sau:
    - `attribute`: Sử dụng selector dạng thuộc tính, trong template: `<div appChild></div>`. khai báo component: selector: `div[appChild]`.
    - `class`: Sử dụng selector dạng class, trong template: `<div class="appChild"></div>`. khai báo component: selector: `div.appChild`.
    - `element`: Sử dụng selector dạng phần tử, trong template: `<app-child-element></app-child-element>`. khai báo component: selector: `app-child-element`.
> Có thể gán selector cho nhiều phần tử cùng lúc, cách nhau bởi dấu phẩy. VD: selector: `div[appChild], div.appChild, app-child-element`.
- **Ví dụ**:
```typescript
import { Component } from '@angular/core';
import { ChildComponent } from './child/child.component'; // Import component con
@Component({
  selector: 'app-parent',
  templateUrl: './parent.component.html',
  styleUrls: ['./parent.component.css'],
  imports: [ChildComponent] // Khai báo component con trong mảng imports
})
export class ParentComponent {
  parentData: string = 'Data from Parent'; // Dữ liệu từ component cha
}
```

### 1.5. Cách truyền dữ liệu từ component cha vào component con
- Để sử dụng các component con trong component cha và truyền dữ liệu từ component cha vào component con, bạn có thể sử dụng:
  - **@Input Decorator**: Sử dụng decorator `@Input` trong component con để nhận dữ liệu từ component cha. `input()` khi muốn sử dụng signal trong component con.
  - **Property Binding**: Sử dụng cú pháp `[propertyName]="value"` trong template của component cha để truyền dữ liệu vào component con.

**Ví dụ**:
```typescript
import { Component, Input } from '@angular/core';
@Component({
  selector: 'app-child',
  templateUrl: './child.component.html',
  styleUrls: ['./child.component.css']
})
export class ChildComponent {
  @Input() childData: string = ''; // Nhận dữ liệu từ component cha
}
```
```template
<p>Child Component</p>
<p>Data from Parent: {{ childData }}</p>
```
```typescript 
import { Component } from '@angular/core';
import { ChildComponent } from './child/child.component'; // Import component con
@Component({
  selector: 'app-parent',
  templateUrl: './parent.component.html',
  styleUrls: ['./parent.component.css'],
  imports: [ChildComponent] // Khai báo component con trong mảng imports
})
export class ParentComponent {
  parentData: string = 'Data from Parent'; // Dữ liệu từ component cha
}
```
```template
<h1>Parent Component</h1>
<p>{{ parentData }}</p>
<app-child [childData]="parentData"></app-child> <!-- Sử dụng component con và truyền dữ liệu -->
``` 

- Để sử dụng nút sự kiện trong component con, bạn có thể sử dụng:
  - **@Output Decorator**: Sử dụng decorator `@Output` trong component con để phát ra sự kiện khi có hành động xảy ra, và sử dụng cú pháp `(eventName)="handler($event)"` trong template của component cha để lắng nghe sự kiện đó.
  - **EventEmitter**: Sử dụng `EventEmitter` để phát ra sự kiện từ component con.
**Ví dụ**:
```typescript
import { Component, Output, EventEmitter } from '@angular/core';
@Component({
  selector: 'app-child',
  templateUrl: './child.component.html',
  styleUrls: ['./child.component.css']
})
export class ChildComponent {
  @Output() childEvent = new EventEmitter<string>();

  triggerEvent(): void {
    this.childEvent.emit('Data from Child');
  }
}
```
```template
<p>Child Component</p>
<button (click)="triggerEvent()">Trigger Event</button>
```
```typescript
import { Component } from '@angular/core';
import { ChildComponent } from './child/child.component'; // Import component con
@Component({
  selector: 'app-parent',
  templateUrl: './parent.component.html',
  styleUrls: ['./parent.component.css'],
  imports: [ChildComponent] // Khai báo component con trong mảng imports
})
export class ParentComponent {
  parentData: string = 'Data from Parent'; // Dữ liệu từ component cha

  handleChildEvent(data: string): void {
    console.log('Received from Child:', data);
  }
}
```
```template
<h1>Parent Component</h1>
<p>{{ parentData }}</p>
<app-child (childEvent)="handleChildEvent($event)"></app-child> <!-- Sử dụng component con và lắng nghe sự kiện -->
```

### 1.6. Sử dụng `ng-content` để chèn nội dung của template con vào template cha
- **`ng-content`** là một chỉ thị trong Angular cho phép bạn chèn nội dung từ template con vào template cha. Điều này rất hữu ích khi bạn muốn tạo các component có thể tái sử dụng với nội dung tùy chỉnh. Giống với `<Outlet>` trong Angular Router, `ng-content` cho phép bạn xác định vị trí mà nội dung sẽ được chèn vào trong component.
- **Cách sử dụng `ng-content`**:
  1. Trong component cha, bạn định nghĩa vị trí chèn nội dung bằng cách sử dụng thẻ `<ng-content></ng-content>`.
  2. Trong component con, bạn có thể đặt nội dung mà bạn muốn chèn vào vị trí đó.
- **Ví dụ**:
```typescript
import { Component } from '@angular/core';
@Component({
  selector: 'app-parent',
  templateUrl: './parent.component.html',
  styleUrls: ['./parent.component.css']
})
export class ParentComponent {
  parentData: string = 'Data from Parent'; // Dữ liệu từ component cha
}
```
```template
<div></div>
  <h1>Parent Component</h1>
  <p>{{ parentData }}</p>
  <ng-content></ng-content> <!-- Vị trí chèn nội dung từ component con -->
```
```typescript
import { Component } from '@angular/core';
@Component({
  selector: 'app-child',
  templateUrl: './child.component.html',
  styleUrls: ['./child.component.css']
})
export class ChildComponent {
  childData: string = 'Data from Child'; // Dữ liệu từ component con
}
```
```template
<app-parent>
  <p>Child Component</p>
  <p>{{ childData }}</p>
  <p>This content will be projected into the Parent Component.</p>
</app-parent> <!-- Nội dung sẽ được chèn vào vị trí ng-content trong component cha -->
```

Trong `ng-content`, bạn có thể sử dụng các selector để chỉ định vị trí chèn nội dung cụ thể. Ví dụ:
```template
<app-parent>
  <ng-content select=".custom-header"></ng-content> <!-- Chèn nội dung có class custom-header -->
  <ng-content/> <!-- Chèn nội dung mặc định -->
  <ng-content select=".custom-content"></ng-content> <!-- Chèn nội dung có class custom-content -->
  <ng-content select="input, textarea"></ng-content> <!-- Chèn nội dung có thẻ input hoặc textarea -->
</app-parent>
```
```template
<app-parent>
  <p class="custom-content">This content will be projected into the Parent Component.</p>
  <h2 class="custom-header">Custom Header</h2>
  <p>This is the default content.</p>
</app-parent> <!-- Nội dung sẽ được chèn vào đúng vị trí ng-content trong component cha, bất kể thứ tự -->
```

Thuộc tính `ngProjectAs` cũng có thể được sử dụng để xác định vị trí chèn nội dung trong component cha
```template cha
<div class="custom-content">
  <ng-content selector="custom-content"></ng-content>
</div>
```
```template con
<app-parent>
  <div class="xxx" ngProjectAs="custom-content">
    <p>This content will be projected into the Parent Component as custom-content.</p>
  </div>
</app-parent> <!-- Nội dung sẽ được chèn vào đúng vị trí ng-content trong component cha -->
```

`Fallback content` là nội dung sẽ được hiển thị nếu không có nội dung nào được chèn vào vị trí `ng-content`. Bạn có thể sử dụng `ng-content` mà không cần selector để định nghĩa fallback content.
```template
<app-parent>
  <ng-content>
    <p>This is fallback content if no content is projected.</p>
  </ng-content> <!-- Fallback content -->
</app-parent>
```
```template
<app-parent>
 <!-- Nếu không có nội dung nào được chèn vào, fallback content sẽ được hiển thị -->
</app-parent> <!-- Nội dung sẽ được chèn vào đúng vị trí ng-content trong component cha -->
```

### 1.7. Hiểu về cách sử dụng `ViewEncapsulation`
- **ViewEncapsulation** là một tính năng trong Angular cho phép bạn kiểm soát cách mà các kiểu CSS được áp dụng cho các component. Có ba chế độ encapsulation chính:
  1. **Emulated**: Đây là chế độ mặc định. Angular sẽ tạo ra các lớp CSS duy nhất cho mỗi component, giúp ngăn chặn xung đột kiểu giữa các component.
  2. **ShadowDom**: Angular sẽ sử dụng Shadow DOM để encapsulate các kiểu CSS. Điều này có nghĩa là các kiểu sẽ chỉ áp dụng cho component đó và không bị ảnh hưởng bởi các kiểu bên ngoài.
  3. **None**: Các kiểu CSS sẽ không được encapsulated, và sẽ áp dụng cho toàn bộ ứng dụng.

Ví dụ:
```typescript
import { Component, ViewEncapsulation } from '@angular/core';

@Component({
  selector: 'app-example',
  templateUrl: './example.component.html',
  styleUrls: ['./example.component.css'],
  encapsulation: ViewEncapsulation.Emulated // Sử dụng chế độ Emulated
})
export class ExampleComponent { }
```

### 1.8. Sử dụng `Service` trong Angular
- **Service** là một phần của Angular dùng để chia sẻ logic và dữ liệu giữa các component. Service giúp bạn tách biệt logic kinh doanh khỏi giao diện người dùng, làm cho mã nguồn dễ bảo trì và tái sử dụng hơn.
- **Cách sử dụng Service**:
  1. Tạo một service bằng cách sử dụng Angular CLI: `ng generate service my-service`.
  2. Định nghĩa các phương thức và thuộc tính trong service.
  3. Sử dụng decorator `@Injectable()` để đánh dấu class là một service có thể được tiêm vào các component khác.
  4. Tiêm service vào component bằng cách sử dụng dependency injection.
- Cách tiêm service vào component:
  - Sử dụng constructor để tiêm service vào component.
  - Sử dụng từ khóa `private` hoặc `public` để xác định phạm vi truy cập của service trong component.
```typescript
import { Injectable } from '@angular/core';
@Injectable({
  providedIn: 'root' // Đăng ký service ở cấp độ root để có thể sử dụng trong toàn bộ ứng dụng
})
export class MyService {
  private data: string = 'Hello from Service'; // Dữ liệu trong service

  getData(): string { // Phương thức để lấy dữ liệu
    return this.data;
  }
}
```
```typescript
import { Component } from '@angular/core';
import { MyService } from './my-service.service'; // Import service
@Component({
  selector: 'app-example',
  templateUrl: './example.component.html',
  styleUrls: ['./example.component.css']
})
export class ExampleComponent {
  serviceData: string = ''; // Biến để lưu dữ liệu từ service

  constructor(private myService: MyService) { // Tiêm service vào component
    this.serviceData = this.myService.getData(); // Lấy dữ liệu từ service
  }

  ngOnInit() {
    this.serviceData = this.myService.getData(); // Lấy dữ liệu từ service
  }
}
```

## 2. Signal trong Angular
- **Signal** là một tính năng mới trong Angular, cho phép bạn quản lý trạng thái và dữ liệu một cách hiệu quả hơn. Signal giúp bạn theo dõi sự thay đổi của dữ liệu và tự động cập nhật giao diện người dùng khi dữ liệu thay đổi.
- **Cách sử dụng Signal**:
  - **Tạo Signal**: Sử dụng hàm `signal()` để tạo một signal mới.
  - **Sử dụng Signal**: Sử dụng cú pháp `signalName()` để truy cập giá trị của signal.
  - **Cập nhật Signal**: Sử dụng cú pháp `signalName.set(value)` để cập nhật giá trị của signal.

- Các giá trị có thể sử dụng trong Signal bao gồm:
  - **Biến**: Các biến được định nghĩa trong class của component.
  - **Hàm get <tên-hàm>**: Các hàm được định nghĩa trong class của component, có thể được sử dụng để lấy giá trị từ signal.
  - **Hàm on<tên-hàm>**: Các hàm được định nghĩa trong class của component, thường được sử dụng để xử lý sự kiện.

> Lưu ý rằng để tạo ra 1 signal khác dựa trên giá trị từ signal nào đó, cần kết hợp với `computed()` để tạo ra một signal mới từ giá trị của signal gốc (Lưu ý `computed` không thể bị ghi đèo, chỉ có thể đọc giá trị từ signal gốc).
```typescript
import { Component, signal, computed } from '@angular/core';
@Component({
  selector: 'app-signal-example',
  templateUrl: './signal-example.component.html',
  styleUrls: ['./signal-example.component.css']
})
export class SignalExampleComponent {
  count = signal(0); // Tạo một signal với giá trị ban đầu là 0

  increment() {
    this.count.set(this.count() + 1); // Cập nhật giá trị của signal
  }

  doubleCount = computed(() => this.count() * 2); // Tạo một signal mới từ giá trị của signal gốc
}
```
```template
<h1>Signal Example Component</h1>
<p>Count: {{ count() }}</p>
<p>Double Count: {{ doubleCount() }}</p>
<button (click)="increment()">Increment</button>
```

## 3. Sử dụng các logic code trong template
- Trong Angular, bạn có thể sử dụng các logic code trong template để hiển thị dữ liệu một cách linh hoạt. Các logic này bao gồm:
  - **Điều kiện**: Sử dụng cú pháp `@if(condition)`, `@else`, `@else if(condition)` để kiểm tra điều kiện và hiển thị nội dung tương ứng.
  - **Lặp**: Sử dụng cú pháp `@for(item of items; track item.id)` để lặp qua một danh sách và hiển thị từng mục. Lưu ý rằng `track` là một tùy chọn để theo dõi các mục trong danh sách, giúp Angular tối ưu hóa việc cập nhật giao diện người dùng.
  - **Biểu thức**: Để thêm biểu thức, chúng ta có các cách sau:
    - Sử dụng cú pháp `{{ expression }}` để chèn giá trị từ component vào template.
    - Sử dụng cú pháp `@let(variable = expression)` để định nghĩa một biến trong template.
    - Sử dụng `[property]="expression"` để liên kết thuộc tính của HTML với giá trị từ component.

## 4. Sử dụng FormsModule trong Angular
- **FormsModule** là một module trong Angular cho phép bạn làm việc với các biểu mẫu (forms) một cách dễ dàng. Nó cung cấp các tính năng như two-way data binding, validation và xử lý sự kiện.
- Để sử dụng FormsModule, bạn cần import nó vào module của bạn:
- **Các tính năng chính của FormsModule**:
  - **NgModel**: Cho phép bạn liên kết dữ liệu hai chiều giữa template và component.
  - **NgSubmit**: Sử dụng để xử lý sự kiện submit của biểu mẫu.
  - **FormControl**: Đại diện cho một trường trong biểu mẫu, cho phép bạn quản lý giá trị và trạng thái của trường đó.
  - **FormGroup**: Đại diện cho một nhóm các trường trong biểu mẫu, cho phép bạn quản lý nhiều trường cùng lúc.
  - **Validation**: Cung cấp các cơ chế để kiểm tra tính hợp lệ của dữ liệu trong biểu mẫu.

>Ví dụ về cách sử dụng FormsModule trong Angular:
```typescript
import { Component } from '@angular/core';
import { FormsModule } from '@angular/forms';
@Component({
  selector: 'app-example',
  templateUrl: './example.component.html',
  styleUrls: ['./example.component.css'],
  imports: [FormsModule] // Import FormsModule để sử dụng ngModel
})
export class ExampleComponent {
  name: string = ''; // Biến để lưu tên người dùng

  onSubmit(): void { // Hàm xử lý sự kiện khi form được submit
    console.log('Submitted name:', this.name);
  }
}
```
```template
<form (ngSubmit)="onSubmit()">
  <label for="name">Name:</label>
  <input type="text" id="name" [(ngModel)]="name" name="name" required>
  <button type="submit">Submit</button>
</form>
```

## 5. Transform data trong Angular với Pipes
- **Pipes** là một tính năng trong Angular cho phép bạn biến đổi dữ liệu trước khi hiển thị nó trong template. Pipes có thể được sử dụng để định dạng ngày tháng, số, chuỗi, v.v.
- **Cách sử dụng Pipes**:
  - Sử dụng cú pháp `{{ value | pipeName:pipeArgument }}` để áp dụng pipe cho giá trị.
  - Bạn có thể tạo các pipe tùy chỉnh bằng cách sử dụng decorator `@Pipe`.

### 5.1. Tạo Pipe tùy chỉnh
- **Ví dụ về cách sử dụng Pipes**:
```typescript
import { Pipe, PipeTransform } from '@angular/core';
@Pipe({
  name: 'uppercase'
})
export class UppercasePipe implements PipeTransform {
  transform(value: string): string {
    return value.toUpperCase(); // Chuyển đổi chuỗi thành chữ hoa
  }
}
```

```typescript
import { Component } from '@angular/core';
import { UppercasePipe } from './uppercase.pipe'; // Import pipe tùy chỉnh
@Component({
  selector: 'app-example',
  templateUrl: './example.component.html',
  styleUrls: ['./example.component.css'],
  imports: [UppercasePipe] // Khai báo pipe tùy chỉnh trong mảng imports
})

export class ExampleComponent {
  title: string = 'Angular Example'; // Biến để lưu tiêu đề
}
```
```template
<h1>{{ title | uppercase }}</h1> <!-- Sử dụng pipe tùy chỉnh để chuyển đổi tiêu đề thành chữ hoa -->
```

### 5.2. Các pipe có sẵn trong Angular
- **DatePipe**: Định dạng ngày tháng.
- **CurrencyPipe**: Định dạng tiền tệ.
- **DecimalPipe**: Định dạng số thập phân.
- **PercentPipe**: Định dạng phần trăm.
- **JsonPipe**: Chuyển đổi đối tượng thành chuỗi JSON.
- **LowerCasePipe**: Chuyển đổi chuỗi thành chữ thường.
- **UpperCasePipe**: Chuyển đổi chuỗi thành chữ hoa.
- **SlicePipe**: Cắt một phần của mảng hoặc chuỗi.
- **AsyncPipe**: Được sử dụng để xử lý các Observable hoặc Promise trong template, tự động đăng ký và hủy đăng ký khi giá trị thay đổi.
```typescript
import { Component } from '@angular/core';
import { Observable, of } from 'rxjs';
@Component({
  selector: 'app-example',
  templateUrl: './example.component.html',
  styleUrls: ['./example.component.css'],
  imports: [AsyncPipe]
})
export class ExampleComponent {
  data$: Observable<string[]> = of(['Item 1', 'Item 2', 'Item 3']);
}
```
```template
<ul>
  <li *ngFor="let item of data$ | async">{{ item }}</li> <!-- Sử dụng AsyncPipe để xử lý Observable -->
</ul>
```

## 6. Sử dụng Angular với Module (standalone = false)
- **Standalone Components**: Là các component độc lập, không cần phải khai báo trong module. Chúng có thể được sử dụng trực tiếp trong template mà không cần phải thêm vào mảng `declarations` của module.
- **Module**: Là một tập hợp các component, dịch vụ và các phần khác của ứng dụng. Mỗi ứng dụng Angular có ít nhất một module gốc (root module).

- Để tạo ứng dụng với `Module`, bạn cần thực hiện tạo một ứng dụng Angular mới bằng cách sử dụng Angular CLI: `ng new <tên-ứng-dụng> --standalone=false --routing=false --ssr=false`.

### 6.1. Cấu trúc của Module
- Mỗi module có một file `module.ts` chứa các thành phần sau:
  - **NgModule Decorator**: Được sử dụng để định nghĩa metadata cho module.
  - **Declarations**: Mảng chứa các component, directive và pipe được khai báo trong module (Component phải là standalone = false).
  - **Imports**: Mảng chứa các module khác mà module này phụ thuộc vào (module và thư viện bên ngoài, component standalone).
  - **Exports**: Mảng chứa các thành phần mà module này muốn xuất ra để sử dụng trong các module khác.
  - **Providers**: Mảng chứa các dịch vụ được cung cấp bởi module.
  - **Bootstrap**: Chỉ định component gốc của ứng dụng, để chạy trong file gốc `main.ts` (Chỉ có trong module gốc).

  ```typescript
  import { NgModule } from '@angular/core';
  import { BrowserModule } from '@angular/platform-browser';
  import { AppComponent } from './app.component';

  @NgModule({
    declarations: [
      AppComponent
    ],
    imports: [
      BrowserModule
    ],
    providers: [],
    bootstrap: [AppComponent]
  })
  export class AppModule { }
  ```
> `BrowserModule` là module cần thiết để chạy ứng dụng Angular trên trình duyệt, nó cung cấp các tính năng cơ bản như rendering, xử lý sự kiện, pipe và các directive cơ bản. Trong các module con, bạn không cần phải import `BrowserModule` nữa, thay vào đó bạn sẽ import `CommonModule` để sử dụng các tính năng chung.
```typescript
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ChildComponent } from './child/child.component';
@NgModule({
  declarations: [
    ChildComponent // Khai báo component con trong module
  ],
  imports: [
    CommonModule // Import CommonModule để sử dụng các tính năng chung
  ],
  exports: [
    ChildComponent // Xuất component con để sử dụng trong các module khác
  ]
})
export class ChildModule { }
```
```typescript
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppComponent } from './app.component';
import { ChildModule } from './child/child.module'; // Import module con

@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    ChildModule // Import module con vào module cha
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
```
```template
<app-child></app-child> <!-- Sử dụng component con trong template của component cha -->
```

### 6.2. Chuyển đổi từ Standalone sang Module
- Để chuyển đổi một component standalone sang module, bạn cần thực hiện các bước sau:
  1. Sửa file chạy ứng dụng `main.ts` để import module thay vì component standalone.

  ```typescript
  // Standalone
  import { bootstrapApplication } from '@angular/platform-browser';
  import { AppComponent } from './app.component';
  bootstrapApplication(AppComponent);
  ```

  ```typescript
  // Module
  import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
  import { AppModule } from './app.module';
  platformBrowserDynamic().bootstrapModule(AppModule)
  .catch(err => console.error(err));
  ```

  2. Tạo một file module mới (ví dụ: `app.module.ts`) và định nghĩa module với các thành phần cần thiết. Cú pháp tạo file module: `ng generate module app --module app.module.ts`.
  3. Chuyển các component, service và các phần khác từ component standalone vào
  module mới. Đảm bảo rằng bạn đã khai báo các component trong mảng `declarations` và import các module cần thiết trong mảng `imports`.
  4. Cập nhật các import trong các file khác để sử dụng module mới thay vì component standalone.

## 7. Host elements
- Host elements là các phần tử DOM mà một component được gắn vào.
- Ví dụ, khi bạn sử dụng một component trong template, phần tử DOM tương ứng sẽ là host element của component đó.
### 7.1. Định nghĩa styles cho host element
- Các `styles` được định nghĩa trong component sẽ được áp dụng cho host element này.
> Với các host element được gán vai trò là thuộc tính cho một element, ví dụ `selector: "button[appButton]"`, bạn có thể dễ dàng định nghĩa các kiểu cho host element (thẻ button) trong file CSS của component, qua từ khóa `:host`.
```ts
@Component({
  selector: "button[appButton]",
  standalone: true,
  imports: [],
  templateUrl: "./button.component.html",
  styleUrl: "./button.component.css",
})
export class ButtonComponent {}
```
```css
/* Thay vì dùng button => :host */
:host {
  display: inline-block;
  padding: 0.65rem 1.35rem;
  border-radius: 0.25rem;
  font-size: 1rem;
  text-align: center;
  cursor: pointer;
  background-color: #691ebe;
  color: white;
  border: none;
}

:host:hover {
  background-color: #551b98;
}

.icon {
  display: inline-block;
  margin-left: 0.5rem;
  transition: transform 0.2s ease-in-out;
}

:host:hover .icon {
  transform: translateX(4px);
}
```

- Với các host element đóng vai trò như là 1 thẻ HTML, bạn có thể định nghĩa các kiểu cho thẻ đó thông qua class được định nghĩa trong thẻ, hoặc qua option `host`:
> Cách 1: Thêm class vào thẻ host
```ts
@Component({
  selector: "app-button",
  standalone: true,
  imports: [],
  templateUrl: "./button.component.html",
  styleUrls: ["./button.component.css"],
})
export class ButtonComponent {}
```
```html
<button class="btn">
  Submit
</button>
```
```css
.btn {
  display: inline-block;
  padding: 0.65rem 1.35rem;
  border-radius: 0.25rem;
  font-size: 1rem;
  text-align: center;
  cursor: pointer;
  background-color: #691ebe;
  color: white;
  border: none;
}

.btn:hover {
  background-color: #551b98;
}

.icon {
  display: inline-block;
  margin-left: 0.5rem;
  transition: transform 0.2s ease-in-out;
}

.btn:hover .icon {
  transform: translateX(4px);
}
```
> Sử dụng option `host` thêm vào ts, html và css giữ nguyên
```ts
@Component({
  selector: "app-button",
  standalone: true,
  imports: [],
  templateUrl: "./button.component.html",
  styleUrls: ["./button.component.css"],
  host: {
    class: "btn"
  }
})
export class ButtonComponent {}
```
### 7.2. Tương tác host element sử dụng `@HostBinding` và `@HostListener`
- `@HostBinding` cho phép bạn liên kết một thuộc tính của host element với một thuộc tính trong component.
- `@HostListener` cho phép bạn lắng nghe các sự kiện từ host element.
> Khi sử dụng `@HostBinding` và `@HostListener`, có thể thay thế cho việc dùng option `host` trong decorator `@Component`.
```ts
import { Component, HostBinding, HostListener } from '@angular/core';

@Component({
  selector: 'app-button',
  standalone: true,
  imports: [],
  templateUrl: './button.component.html',
  styleUrls: ['./button.component.css'],
  host: {
    class: 'btn', // Thêm class btn cho host element
    '(click)': 'onClick($event)' // Gán sự kiện click cho host element, gọi onClick đã định nghĩa
  }
})
export class ButtonComponent {
  @HostBinding('class') className = 'btn'; // Định nghĩa thuộc tính class cho host element

  @HostListener('click', ['$event'])

  onClick(event: MouseEvent) {
    console.log('Button clicked:', event);
  }
}