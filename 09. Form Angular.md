# Làm việc với Form trong Angular
## 1. Giới thiệu
Angular cung cấp hai cách để làm việc với form: Template-driven và Reactive.
- `Template-driven form` là cách tiếp cận đơn giản, dễ sử dụng cho các form nhỏ.
- `Reactive form` cung cấp nhiều tính năng mạnh mẽ hơn, phù hợp cho các form phức tạp.

## 2. So sánh
| Tiêu chí         | Template-driven form                | Reactive form                       |
|------------------|-------------------------------------|-------------------------------------|
| Cách tiếp cận    | Dựa trên template                   | Dựa trên mã nguồn                   |
| Quản lý trạng thái| Tự động, thông qua ngữ cảnh       | Thủ công, thông qua FormGroup     |
| Tính linh hoạt    | Ít linh hoạt hơn                    | Rất linh hoạt                       |
| Kiểm tra hợp lệ   | Dễ dàng, nhưng hạn chế              | Phức tạp hơn, nhưng mạnh mẽ hơn    |
| Tính mở rộng      | Khó mở rộng cho các form phức tạp  | Dễ dàng mở rộng                     |

## 3. Template-driven Form
- Làm việc với template-driven form trong Angular rất đơn giản. Bạn chỉ cần sử dụng các directive như `ngModel` để liên kết dữ liệu giữa form và component.
- Ví dụ:
```html
<form #myForm="ngForm" (ngSubmit)="onSubmit(myForm)"> <!-- Lấy tham chiếu đến form và xử lý sự kiện submit -->
  <input type="text" name="username" ngModel required> <!-- Liên kết dữ liệu 2 chiều giữa input và component -->
  <button [disabled]="myForm.invalid">Submit</button>
</form>
```
```ts
import { Component } from '@angular/core';
import { NgForm, FormModules } from '@angular/forms';

@Component({
  selector: 'app-template-driven-form',
  templateUrl: './template-driven-form.component.html',
  providers: [FormsModule]
})
export class TemplateDrivenFormComponent {
  onSubmit(formModal: NgForm) {
    console.log(formModal.form.value); // { username: '...' }
  }
}
```

> Lưu ý khi sử dụng `ngModel`: 
- Chỉ sử dụng trong các form template-driven, không sử dụng trong reactive form.
- `ngForm` giúp quản lý trạng thái của form và cung cấp thông tin về tính hợp lệ của form.
- Khi sử dụng `ngModel`, `ngSubmit` cần import thêm `FormsModule` trong module chứa component.
- `ngModel` chỉ hỗ trợ trong các thẻ `<input>`, `<select>`, và `<textarea>`, và muốn liên kết được cần thêm thuộc tính `name` vào các thẻ này. Giá trị của `ngModel` sẽ được đồng bộ hóa với giá trị của input.
- Có thể không cần sử dụng `ngForm`, chỉ sử dụng `ngModel` với ý nghĩa tạo ra liên kết 2 chiều giữa input và component. `[(ngModel)]` là cú pháp viết tắt của `ngModel` và `ngModelChange`, giúp đồng bộ hóa giá trị giữa input và component. Giá trị của thuộc tính `name` cũng chính là biến trong component.

### 3.1. Validate form
- Đối với template-driven form, Angular cung cấp các directive để kiểm tra tính hợp lệ của form như `required`, `minlength`, `maxlength`, `pattern`, v.v. bằng cách thêm các thuộc tính này vào các thẻ `<input>`, `<select>`, và `<textarea>`.
- Cùng với đó, Angular cũng cung cấp các class CSS để hiển thị trạng thái hợp lệ của form như (chúng ta sử dụng các class này để style css):
  - `ng-valid` - trạng thái hợp lệ
  - `ng-invalid` - trạng thái không hợp lệ
  - `ng-pristine` - trạng thái chưa thay đổi (người dùng chưa nhập gì)
  - `ng-dirty` - trạng thái đã thay đổi.
  - `ng-touched` - trạng thái đã được người dùng tương tác (focus và blur).
  - `ng-submitted` - trạng thái đã được gửi (submit).
  - `ng-untouched` - trạng thái chưa được người dùng tương tác.

- Kết hợp với các class này, bạn có thể sử dụng các thuộc tính như `.valid`, `.invalid`, `.pristine`, `.dirty`, `.touched`, `.untouched`, và `.submitted` để kiểm tra trạng thái của form trong component, bằng cách tham chiếu đến các biến template này gán với `ngModel`

```html
<form #myForm="ngForm" (ngSubmit)="onSubmit(myForm)">
  <input type="email" name="email" ngModel required #email="ngModel">
  <input type="password" name="password" ngModel required minlength="6" #password="ngModel">
  <button [disabled]="myForm.invalid">Submit</button>
</form>

@ if (email.touched && email.dirty && email.invalid) { // Nếu trường email đã được người dùng tương tác và thay đổi, và không hợp lệ
  // Hiển thị thông báo lỗi cho email
  <p>Email không hợp lệ</p>
}

@ if (password.touched && password.dirty && password.invalid) { // Nếu trường password đã được người dùng tương tác và thay đổi, và không hợp lệ
  // Hiển thị thông báo lỗi cho password
  <p>Password không hợp lệ</p>
}
```

### 3.2. Lắng nghe thay đổi
- Để lắng nghe các thay đổi trong form, bạn có thể sử dụng thuộc tính `valueChanges` của `NgForm` hoặc `FormGroup`.
- `valueChanges` sẽ trả ra 1 observable, cho phép bạn theo dõi các thay đổi trong giá trị của form, kết hợp với `debounceTime` để giảm thiểu số lần phát ra giá 
trị mới.
- Thêm vào đó sử dụng `afterNextRender` để đảm bảo rằng form đã được render trước khi lắng nghe các thay đổi.
- Ví dụ:
```ts
import {
  afterNextRender,
  Component,
  DestroyRef,
  inject,
  viewChild,
} from "@angular/core";
import { FormsModule, NgForm } from "@angular/forms";
import { debounceTime } from "rxjs";

@Component({
  selector: "app-login",
  standalone: true,
  templateUrl: "./login.component.html",
  styleUrl: "./login.component.css",
  imports: [FormsModule],
})
export class LoginComponent {
  formView = viewChild<NgForm>("form");
  destroyRef = inject(DestroyRef);

  constructor() {
    afterNextRender(() => {
      const jsonLogin = window.localStorage.getItem("user-login-form");

      if (jsonLogin) {
        const parseLogin = JSON.parse(jsonLogin);
        const savedEmail = parseLogin.email;
        console.log("Saved Email:", savedEmail);
        setTimeout(() => {
          this.formView()?.setValue({
            email: savedEmail || "",
            password: "", // Đặt password rỗng vì không lưu trữ password trong localStorage
          });
          // Hoặc có thể set cho từng trường riêng lẻ
          // this.formView()?.controls["email"].setValue(savedEmail || "");
        }, 1); // sử dụng setTimeout để đảm bảo rằng form đã được khởi tạo trước khi set giá trị
      }

      // sử dụng afterNextRender để đảm bảo rằng form đã được render (vì thế cần phải viewChild để lấy được thông tin form)
      const sub = this.formView()
        ?.valueChanges?.pipe(debounceTime(500)) // valueChange (lắng nghe form có thay đổi dữ liệu không => trả về 1 observables), debounceTime (chờ 500ms trước khi phát ra giá trị mới, tránh việc phát ra quá nhiều giá trị gây nghẽn)
        .subscribe({
          next: (val) =>
            window.localStorage.setItem(
              "user-login-form",
              JSON.stringify({ email: val.email })
            ),
        });

      this.destroyRef.onDestroy(() => {
        sub?.unsubscribe();
      });
    });
  }

  onSubmit(form: NgForm) {
    const enteredEmail = form.form.value.email;
    const enteredPassword = form.form.value.password;

    if (form.invalid) {
      return;
    }
    console.log("Email:", enteredEmail);
    console.log("Password:", enteredPassword);
    form.resetForm(); // Reset the form after submission
  }
}

```

## 4. Reactive Forms
- Reactive Forms cung cấp một cách tiếp cận mạnh mẽ và linh hoạt hơn để làm việc với các biểu mẫu trong Angular.
- Thay vì sử dụng ngModel để liên kết dữ liệu, Reactive Forms sử dụng FormGroup và FormControl để quản lý trạng thái và giá trị của các trường trong biểu mẫu.
- Điều này cho phép bạn dễ dàng kiểm soát và theo dõi các thay đổi trong biểu mẫu, cũng như thực hiện các xác thực phức tạp hơn.
- Trong `Reactive Form` chúng ta sẽ làm quen với các thuật ngữ:
  - `formGroup`: đại diện cho một nhóm các trường trong biểu mẫu.
  - `formControl`: đại diện cho một trường trong biểu mẫu.
  - `formControlName`: đại diện cho tên của một trường trong biểu mẫu, được sử dụng để liên kết một `FormControl` với một trường trong template.
  - `ReactiveFormsModule`: module cần thiết để sử dụng Reactive Forms trong Angular.
  - `ngSubmit`: sự kiện được phát ra khi người dùng gửi biểu mẫu.

Để sử dụng Reactive Forms, bạn cần thực hiện các bước sau:
1. Import `ReactiveFormsModule` vào module của bạn (thay vì `FormsModule`).
```ts
// ...
import { ReactiveFormsModule } from "@angular/forms";
@Component({
  // ...
  imports: [ReactiveFormsModule]
})
```
2. Tạo một `FormGroup` trong component của bạn để đại diện cho biểu mẫu.
```ts
// ...
export class Example {
  form = new FormGroup({
    email: new FormControl(""), // Khởi tạo giá trị đầu tiên là một chuỗi rỗng
    password: new FormControl("") // Khởi tạo giá trị đầu tiên là một chuỗi rỗng
  })
}
```
3. Sử dụng `formControlName` hoặc `formControl` và `formGroup` trong template để liên kết các trường với `FormControl` tương ứng trong `FormGroup`.
```html
<form [formGroup]="form" (ngSubmit)="onSubmit()">
  <h2>Login</h2>

  <div class="control-row">
    <div class="control no-margin">
      <label for="email">Email</label>
      <input id="email" type="email" [formControl]="form.controls.email" />
    </div>

    <div class="control no-margin">
      <label for="password">Password</label>
      <input id="password" type="password" formControlName="password" />
    </div>

    <button class="button">Login</button>
  </div>
</form>

```
4. Xử lý sự kiện `ngSubmit` để lấy giá trị của biểu mẫu khi người dùng gửi (không cần truyền bất cứ gì vào hàm `onSubmit` vì chúng ta đã liên kết biểu mẫu với `FormGroup`).
```ts
//...
onSubmit() {
  console.log(this.form.value)
}
```

### 4.1. Validate dữ liệu
- Angular cũng cung cấp cho các class CSS để hiển thị trạng thái hợp lệ của form như (chúng ta sử dụng các class này để style css):
  - `ng-valid` - trạng thái hợp lệ
  - `ng-invalid` - trạng thái không hợp lệ
  - `ng-pristine` - trạng thái chưa thay đổi (người dùng chưa nhập gì)
  - `ng-dirty` - trạng thái đã thay đổi.
  - `ng-touched` - trạng thái đã được người dùng tương tác (focus và blur).
  - `ng-submitted` - trạng thái đã được gửi (submit).
  - `ng-untouched` - trạng thái chưa được người dùng tương tác.

- Khác với `Form-template`, `Reactive Form` không sử dụng các thuộc tính như `required`, `minlength`, `maxlength`, `pattern`, v.v. để kiểm tra tính hợp lệ của form, mà sử dụng các phương thức của `Validators` để kiểm tra tính hợp lệ của form. Các phương thức đó được sử dụng trong `FormControl` của từng trường.
```ts
import { Validators } from "@angular/forms";

this.form = new FormGroup({
  email: new FormControl("", {
    validators: [Validators.required, Validators.email],
  }),
  password: new FormControl("", {
    validators: [Validators.required, Validators.minLength(6)],
  }),
});
```
> Ngoài thuộc tính `validators`, còn có `asyncValidators` cho phép bạn xác thực bất đồng bộ (như kiểm tra email đã tồn tại hay chưa), `updateOn` để chỉ định thời điểm cập nhật giá trị và trạng thái của `FormControl` (ví dụ: `change`, `blur`, `submit`), `nonNullable` để chỉ định rằng giá trị của `FormControl` không bao giờ là null.

```ts
import { Component } from "@angular/core";
import {
  FormControl,
  FormGroup,
  ReactiveFormsModule,
  Validators,
} from "@angular/forms";

@Component({
  selector: "app-login",
  standalone: true,
  templateUrl: "./login.component.html",
  styleUrl: "./login.component.css",
  imports: [ReactiveFormsModule],
})
export class LoginComponent {
  form = new FormGroup({
    email: new FormControl("", {
      validators: [Validators.required, Validators.email],
    }),
    password: new FormControl("", {
      validators: [Validators.required, Validators.minLength(6)],
    }),
  });

  get isValidEmail() {
    return (
      this.form.controls.email.touched &&
      this.form.controls.email.dirty &&
      this.form.controls.email.invalid
    );
  }

  get isValidPassword() {
    return (
      this.form.controls.password.touched &&
      this.form.controls.password.dirty &&
      this.form.controls.password.invalid
    );
  }

  onSubmit() {
    console.log(this.form.value);
  }
}
```
```html
<form [formGroup]="form" (ngSubmit)="onSubmit()">
  <h2>Login</h2>

  <div class="control-row">
    <div class="control no-margin">
      <label for="email">Email</label>
      <input id="email" type="email" [formControl]="form.controls.email" />
    </div>

    <div class="control no-margin">
      <label for="password">Password</label>
      <input id="password" type="password" formControlName="password" />
    </div>

    <button class="button">Login</button>
  </div>

  @if (isValidEmail) {
    <p class="control-error">Email is invalid</p>
  }

  @if (isValidPassword) {
    <p class="control-error">Password is invalid</p>
  }
</form>
```
### 4.2. Tạo custom validate
Ngoài `directive`, chúng ta có thể tạo custom validate cho `FormControl` bằng cách tạo một hàm validate và truyền vào `validators` của `FormControl`.

```ts
import { AbstractControl } from "@angular/forms";

function mustContainQuestionMark(control: AbstractControl) {
  if (control.value.includes("?")) {
    return null; // Valid
  }
  return { notContainQuestionMark: true }; // Invalid
}

@Component({
  selector: "app-login",
  standalone: true,
  templateUrl: "./login.component.html",
  styleUrl: "./login.component.css",
  imports: [ReactiveFormsModule],
})
export class LoginComponent {
  form = new FormGroup({
    email: new FormControl("", {
      validators: [Validators.required, Validators.email],
    }),
    password: new FormControl("", {
      validators: [Validators.required, Validators.minLength(6), mustContainQuestionMark],
    }),
  });

  get isValidEmail() {
    return (
      this.form.controls.email.touched &&
      this.form.controls.email.dirty &&
      this.form.controls.email.invalid
    );
  }

  get isValidPassword() {
    return (
      this.form.controls.password.touched &&
      this.form.controls.password.dirty &&
      this.form.controls.password.invalid
    );
  }

  onSubmit() {
    console.log(this.form.value);
  }
}
```


### 4.3. Sử dụng `asyncValidators`
`asyncValidators` cho phép bạn thực hiện xác thực bất đồng bộ, chẳng hạn như kiểm tra xem email đã tồn tại hay chưa trong db trước khi đi tiếp. Để sử dụng `asyncValidators`, bạn cần truyền một hàm trả về một `Observable` vào `asyncValidators` của `FormControl`.

```ts
import { AbstractControl } from "@angular/forms";
import { of } from "rxjs";
import { map, delay } from "rxjs/operators";

function emailExists(control: AbstractControl) {
  const email = control.value;
  return of(email).pipe(
    delay(1000), // Giả lập gọi API
    map((email) => {
      return email === "test@example.com"
        ? { emailExists: true }
        : null;
    })
  );
}

@Component({
  selector: "app-login",
  standalone: true,
  templateUrl: "./login.component.html",
  styleUrl: "./login.component.css",
  imports: [ReactiveFormsModule],
})
export class LoginComponent {
  form = new FormGroup({
    email: new FormControl("", {
      validators: [Validators.required, Validators.email],
      asyncValidators: [emailExists],
    }),
    password: new FormControl("", {
      validators: [Validators.required, Validators.minLength(6), mustContainQuestionMark],
    }),
  });

  get isValidEmail() {
    return (
      this.form.controls.email.touched &&
      this.form.controls.email.dirty &&
      this.form.controls.email.invalid
    );
  }

  get isValidPassword() {
    return (
      this.form.controls.password.touched &&
      this.form.controls.password.dirty &&
      this.form.controls.password.invalid
    );
  }

  onSubmit() {
    console.log(this.form.value);
  }
}
```

### 4.4. Khởi tạo giá trị mặc định
Với `Reactive Form` bạn có thể khởi tạo giá trị mặc định cho các trường trong `FormGroup` bằng cách truyền giá trị vào khi tạo `FormControl`. Nếu bạn muốn khởi tạo giá trị mặc định cho toàn bộ form, bạn có thể sử dụng phương thức `setValue` hoặc `patchValue` (chỉ cập nhật 1 phần, còn lại giữ nguyên) để cập nhật giá trị của form sau khi đã khởi tạo.

> Khởi tạo ngay lúc khai báo
```ts
import { FormGroup, FormControl } from "@angular/forms";

@Component({
  selector: "app-login",
  standalone: true,
  templateUrl: "./login.component.html",
  styleUrl: "./login.component.css",
  imports: [ReactiveFormsModule],
})
export class LoginComponent {
  form = new FormGroup({
    email: new FormControl("test@example.com", {
      validators: [Validators.required, Validators.email],
    }),
    password: new FormControl("123456?", {
      validators: [Validators.required, Validators.minLength(6), mustContainQuestionMark],
    }),
  });
}
```

Ví dụ đầy đủ:
```ts
import { Component, DestroyRef, inject, OnInit } from "@angular/core";
import {
  AbstractControl,
  FormControl,
  FormGroup,
  ReactiveFormsModule,
  Validators,
} from "@angular/forms";
import { debounceTime, delay, map, of } from "rxjs";

function mustContainQuestionMark(control: AbstractControl) {
  if (control.value.includes("?")) {
    return null; // Valid
  }
  return { notContainQuestionMark: true }; // Invalid
}

function isNotDuplicate(control: AbstractControl) {
  const email = control.value;
  return of(email).pipe(
    delay(1000), // Giả lập đang gọi đến backend check trùng (trễ 1s)
    map((email) => {
      if (email === "messiprohy@gmail.com") return { isDuplicate: true };
      return null;
    })
  );
}

/**
 * Dùng init set vào FormControl
 * */
let initialEmailValue = "";
const savedForm = window.localStorage.getItem("saved-login-form");

if (savedForm) {
  const loadedForm = JSON.parse(savedForm);
  initialEmailValue = loadedForm.email;
}
@Component({
  selector: "app-login",
  standalone: true,
  templateUrl: "./login.component.html",
  styleUrl: "./login.component.css",
  imports: [ReactiveFormsModule],
})
export class LoginComponent implements OnInit {
  destroyRef = inject(DestroyRef);

  form = new FormGroup({
    email: new FormControl(initialEmailValue, {
      validators: [Validators.required, Validators.email],
      asyncValidators: [isNotDuplicate],
    }),
    password: new FormControl("", {
      validators: [
        Validators.required,
        Validators.minLength(6),
        mustContainQuestionMark,
      ],
    }),
  });

  get isValidEmail() {
    return (
      this.form.controls.email.touched &&
      this.form.controls.email.dirty &&
      this.form.controls.email.invalid
    );
  }

  get isValidPassword() {
    return (
      this.form.controls.password.touched &&
      this.form.controls.password.dirty &&
      this.form.controls.password.invalid
    );
  }

  ngOnInit(): void {
    /** Dùng patchValue */
    // const savedForm = window.localStorage.getItem("saved-login-form");

    // if (savedForm) {
    //   const loadedForm = JSON.parse(savedForm);
    //   this.form.patchValue({
    //     email: loadedForm.email,
    //   });
    // }
    const sub = this.form.valueChanges.pipe(debounceTime(500)).subscribe({
      next: (value) => {
        window.localStorage.setItem(
          "saved-login-form",
          JSON.stringify({ email: value.email })
        );
      },
    });
    this.destroyRef.onDestroy(() => {
      sub.unsubscribe();
    });
  }

  onSubmit() {
    console.log(this.form.value);
  }
}
```