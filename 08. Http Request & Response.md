# Http request & Handling response
## 1. Giới thiệu
- **HttpClient** là một dịch vụ trong Angular giúp bạn thực hiện các yêu cầu HTTP (GET, POST, PUT, DELETE, v.v.) một cách dễ dàng và hiệu quả.

## 2. Cách sử dụng HttpClient (GET)

- Để sử dụng HttpClient, truớc tiên cần thêm `provideHttpClient` vào danh sách các provider trong ứng dụng của bạn (thường đặt trong main.ts đối với `standalone components` hoặc trong app.module.ts (@NgModule) đối với các ứng dụng không phải standalone, module).

> Ví dụ Trong file `main.ts` thêm tùy chọn providers `provideHttpClient` vào config.
  ```ts
  import { bootstrapApplication } from '@angular/platform-browser';
  import { AppComponent } from './app/app.component';
  import { appConfig } from './app/app.config';
  import { provideHttpClient } from "@angular/common/http";

  bootstrapApplication(AppComponent, {
    providers: [
      appConfig.providers,
      provideHttpClient()
    ]
  });
  ```

- Sau đó, inject `HttpClient` vào component hoặc service của bạn để sử dụng.
  ```ts
  import { HttpClient } from '@angular/common/http';
  import { Component, inject } from '@angular/core';

  @Component({
    selector: 'app-example',
    templateUrl: './example.component.html',
  })
  export class ExampleComponent {
    private httpClient = inject(HttpClient);

    constructor() {
      this.httpClient.get<type>('/api/data').subscribe({
        next: (data) => {
          console.log(data);
        },
        error: (error) => {
          console.error(error);
        }
      });
    }
  }
  ```

### 2.1. Transforming Data với RxJS (Pipe)
- Vì method `get` tạo ra một Observable, bạn có thể sử dụng các toán tử RxJS để xử lý dữ liệu trả về một cách linh hoạt hơn. Muốn lọc dữ liệu, bạn có thể sử dụng toán tử `map`:
  ```ts
  import { HttpClient } from '@angular/common/http';
  import { Component, inject } from '@angular/core';
  import { map } from 'rxjs/operators';

  @Component({
    selector: 'app-example',
    templateUrl: './example.component.html',
  })
  export class ExampleComponent {
    private httpClient = inject(HttpClient);

    constructor() {
      this.httpClient.get<type>('/api/data').pipe(
        map((data) => {
          // Xử lý dữ liệu ở đây
          return data;
        })
      ).subscribe({
        next: (data) => {
          console.log(data);
        },
        error: (error) => {
          console.error(error);
        }
      });
    }
  }
  ```

> Vì là 1 observable được `subcribe` nên có thể hủy đăng ký (unsubscribe) khi không còn cần thiết, giúp tránh rò rỉ bộ nhớ bằng cách sử dụng `destroyRef` hoặc `ngOnDestroy` trong component.

### 2.2. Cấu hình thêm cho HttpClient
- Có thể tùy chọn cấu hình thêm cho HttpClient như headers, params, và observe. Trong đó:
  - `headers`: Thêm các header tùy chỉnh cho yêu cầu HTTP.
  - `params`: Thêm các tham số truy vấn cho yêu cầu HTTP.
  - `observe`: Xác định cách mà bạn muốn nhận phản hồi từ yêu cầu HTTP (ví dụ: "response" để nhận toàn bộ phản hồi, "body" để chỉ nhận phần body, "events" để nhận các sự kiện liên quan đến yêu cầu).

  ```ts
  this.httpClient.get<type>('/api/data', {
    headers: {
      'Custom-Header': 'value'
    },
    params: {
      id: '123'
    },
    observe: 'response'
  }).subscribe({
    next: (response) => {
      console.log(response.body);
    },
    error: (error) => {
      console.error(error);
    }
  });
  ```

### 2.3. Sử dụng loading state
- Trong quá trình thực hiện yêu cầu HTTP, bạn có thể sử dụng một biến trạng thái để hiển thị thông báo "Loading..." cho người dùng. Ví dụ:
```ts
import { HttpClient } from '@angular/common/http';
import { Component, inject } from '@angular/core';
import { map } from 'rxjs/operators';

@Component({
  selector: 'app-example',
  templateUrl: './example.component.html',
})
export class ExampleComponent {
  private httpClient = inject(HttpClient);
  isLoading = false;

  constructor() {
    this.loadData();
  }

  loadData() {
    this.isLoading = true;
    this.httpClient.get<type>('/api/data').pipe(
      map((data) => {
        // Xử lý dữ liệu ở đây
        return data;
      })
    ).subscribe({
      next: (data) => {
        console.log(data);
      },
      error: (error) => {
        console.error(error);
      },
      complete: () => {
        this.isLoading = false; // Kết thúc quá trình tải dữ liệu
      }
    });
  }
}
```
```html
@if (isLoading) {
  <p class="fallback-text">Loading...</p>
}
```

### 2.4. Xử lý lỗi
- Đối với việc xử lý lỗi, bạn có thể sử dụng một biến trạng thái kết hợp các toán tử RxJS để hiển thị thông báo lỗi cho người dùng. Ví dụ:
```ts
import { Component, DestroyRef, inject, OnInit, signal } from "@angular/core";

import { Place } from "../place.model";
import { PlacesComponent } from "../places.component";
import { PlacesContainerComponent } from "../places-container/places-container.component";
import { HttpClient } from "@angular/common/http";
import { catchError, map, throwError } from "rxjs";

@Component({
  selector: "app-available-places",
  standalone: true,
  templateUrl: "./available-places.component.html",
  styleUrl: "./available-places.component.css",
  imports: [PlacesComponent, PlacesContainerComponent],
})
export class AvailablePlacesComponent implements OnInit {
  places = signal<Place[] | undefined>(undefined);
  isFetching = signal<boolean>(true);
  errorMsg = signal<string | null>(null);
  private httpClient = inject(HttpClient);
  private destroyRef = inject(DestroyRef);

  ngOnInit(): void {
    const subcription = this.httpClient
      .get<{ places: Place[] }>("http://localhost:3000/places", {
        headers: {
          "Content-Type": "application/json",
        },
        observe: "response",
      })
      .pipe(
        map((res) => res.body?.places),
        catchError((error) => {
          console.log(error);
          return throwError(() => new Error("Failed to fetch places")); // ném ra lỗi
        })
      )
      .subscribe({
        next: (places) => {
          this.places.set(places);
        },
        error: (error: Error) => {
          console.error(error.message); // msg lỗi chính từ chỗ ném lỗi ở catchError
          this.errorMsg.set(error.message);
        },
        complete: () => {
          this.isFetching.update(() => false);
        },
      });

    this.destroyRef.onDestroy(() => {
      subcription.unsubscribe();
    });
  }
}

```
```html
<app-places-container title="Available Places">
  @if (isFetching() && !errorMsg()) {
    <p class="fallback-text">Loading places...</p>
  }
  @if (errorMsg()) {
    <p class="fallback-text">{{ errorMsg() }}</p>
  }

  @if (places()) {
    <app-places [places]="places()!" />
  } @else if (places()?.length === 0) {
    <p class="fallback-text">Unfortunately, no places could be found.</p>
  }
</app-places-container>
```

## 3. Gửi dữ liệu (POST, PUT, DELETE)
- Để gửi dữ liệu đến máy chủ, bạn có thể sử dụng các phương thức như POST, PUT hoặc DELETE. Với các tham số bao gồm:
    - `body`: Dữ liệu bạn muốn gửi đến máy chủ.
    - `headers` và `observe`:  Các tiêu đề HTTP (nếu cần) và Cách bạn muốn quan sát phản hồi (ví dụ: 'response' để nhận toàn bộ phản hồi).
> VD:
```ts
this.httpClient.post('/api/data', 
    {
        name: 'New Item'
    },
    {
        headers: {
            'Content-Type': 'application/json'
        },
        observe: 'response'
    }
).subscribe({
    next: (response) => {
        console.log(response);
    },
    error: (error) => {
        console.error(error);
    },
    complete: () => {
        console.log('Request complete');
    }
});
```
### 3.1. Optimistic Update
- Để cải thiện trải nghiệm người dùng, bạn có thể thực hiện cập nhật lạc quan (optimistic update). Điều này có nghĩa là bạn sẽ cập nhật giao diện người dùng ngay lập tức mà không cần chờ đợi phản hồi từ máy chủ. Nếu phản hồi từ máy chủ thành công, bạn giữ nguyên cập nhật. Nếu có lỗi xảy ra, bạn sẽ hoàn tác cập nhật.

Để làm điều đó, kết hợp cập nhật vào các tín hiệu để cho hiển thị trước rồi thực hiện http-request.

```ts
/**
 * Service
*/
import { inject, Injectable, signal } from "@angular/core";

import { Place } from "./place.model";
import { HttpClient } from "@angular/common/http";
import { catchError, map, tap, throwError } from "rxjs";

@Injectable({
  providedIn: "root",
})
export class PlacesService {
  private httpClient = inject(HttpClient);
  private userPlaces = signal<Place[]>([]);

  loadedUserPlaces = this.userPlaces.asReadonly();

  loadAvailablePlaces() {
    return this.fetchPlaces(
      "http://localhost:3000/places",
      "Failed to fetch places"
    );
  }

  loadUserPlaces() {
    return this.fetchPlaces(
      "http://localhost:3000/user-places",
      "Failed to fetch user places"
    ).pipe(
      tap({
        next: (userPlaces) => this.userPlaces.set(userPlaces),
      })
    );
  }

  addPlaceToUserPlaces(place: Place) {
    const prevPlaces = this.userPlaces(); // Lưu trữ danh sách địa điểm trước đó

    if (!prevPlaces.some((p) => p.id === place.id)) {
      this.userPlaces.update((prev) => [...prev, place]);
    } // Nếu địa điểm chưa tồn tại trong danh sách, thêm nó vào

    return this.httpClient
      .put("http://localhost:3000/user-places", {
        placeId: place.id,
      })
      .pipe(
        catchError((err) => {
          this.userPlaces.set(prevPlaces); // Khôi phục lại danh sách địa điểm trước đó nếu có lỗi
          return throwError(
            () => new Error("Failed to add place to user places")
          );
        })
      );
  }

  removeUserPlace(place: Place) {}

  private fetchPlaces(url: string, errorMsg: string) {
    return this.httpClient
      .get<{ places: Place[] }>(url, {
        headers: {
          "Content-Type": "application/json",
        },
      })
      .pipe(
        map((res) => res.places),
        catchError((error) => {
          console.log(error);
          return throwError(() => new Error(errorMsg)); // ném ra lỗi
        })
      );
  }
}

/**
 * Component
 *
 */
import { Component, DestroyRef, inject, OnInit, signal } from "@angular/core";

import { PlacesContainerComponent } from "../places-container/places-container.component";
import { PlacesComponent } from "../places.component";
import { Place } from "../place.model";
import { HttpClient } from "@angular/common/http";
import { catchError, map, throwError } from "rxjs";
import { PlacesService } from "../places.service";

@Component({
  selector: "app-user-places",
  standalone: true,
  templateUrl: "./user-places.component.html",
  styleUrl: "./user-places.component.css",
  imports: [PlacesContainerComponent, PlacesComponent],
})
export class UserPlacesComponent implements OnInit {
  isFetching = signal<boolean>(true);
  errorMsg = signal<string | null>(null);
  private placeService = inject(PlacesService);
  private destroyRef = inject(DestroyRef);
  places = this.placeService.loadedUserPlaces;

  ngOnInit(): void {
    this.isFetching.set(true);
    const subscription = this.placeService.loadUserPlaces().subscribe({
      error: (error: Error) => {
        console.error(error);
        this.errorMsg.set(error.message);
        this.isFetching.set(false);
      },
      complete: () => {
        this.isFetching.set(false);
      },
    });

    this.destroyRef.onDestroy(() => {
      subscription.unsubscribe();
    });
  }
}
```

> RxJS `tap` operator cho phép bạn thực hiện một hành động phụ (side effect) với dữ liệu mà không làm thay đổi nó. Trong trường hợp này, chúng ta sử dụng `tap` để cập nhật trạng thái của `userPlaces` trong `PlacesService` mà không làm thay đổi dữ liệu phản hồi từ máy chủ. Như vậy trong component chỉ cần lấy ra biến `loadedUserPlaces` là có thể sử dụng được dữ liệu mà không cần phải xử lý thêm `next` trong subscribe.

## 4. Http Interceptors
- Http Interceptors là một tính năng mạnh mẽ trong Angular cho phép bạn can thiệp vào các yêu cầu và phản hồi HTTP. Bạn có thể sử dụng chúng để thêm các header, xử lý lỗi, hoặc thực hiện các hành động khác trước khi yêu cầu được gửi đi hoặc sau khi nhận được phản hồi.

### 4.1. Request Interceptor
> Để tạo một Http Interceptor, bạn cần tạo một function để xử lý chặn 
```ts
import { HttpHandlerFn, HttpRequest } from "@angular/common/http";

export function authInterceptor(
  request: HttpRequest<unknown>,
  next: HttpHandlerFn
) {
  console.log("Auth Interceptor");
  const req = request.clone({
    headers: request.headers.set("Authorization", "Bearer YOUR_TOKEN"),
  });
  console.log(req);
  return next(req);
}
```
Sau đó truyền vào trong mảng `withInterceptors` khi gọi `provideHttpClient` trong `main.ts`:
```ts
import { bootstrapApplication } from "@angular/platform-browser";

import { AppComponent } from "./app/app.component";
import { provideHttpClient, withInterceptors } from "@angular/common/http";
import { authInterceptor } from "./app/interceptors/Auth.interceptors";

bootstrapApplication(AppComponent, {
  providers: [provideHttpClient(withInterceptors([authInterceptor]))],
}).catch((err) => console.error(err));
```

> Ngoài ra, bạn có thể định nghĩa 1 class để làm interceptor:
```ts
import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent } from "@angular/common/http";
import { Observable } from "rxjs";
import { Injectable } from "@angular/core";

@Injectable()
export class AuthInterceptor implements HttpInterceptor {
  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    console.log("Auth Interceptor");
    const cloned = req.clone({
      headers: req.headers.set("Authorization", "Bearer YOUR_TOKEN"),
    });
    console.log(cloned);
    return next.handle(cloned);
  }
}
```
Sau đó, thay vì dùng `withInterceptors()` (sử dụng cho function) thì bạn sẽ dùng `withInterceptorsFromDi()` (sử dụng cho class), kết hợp với việc cung cấp interceptor qua DI.

```ts
import { bootstrapApplication } from "@angular/platform-browser";

import { AppComponent } from "./app/app.component";
import {
  HTTP_INTERCEPTORS,
  provideHttpClient,
  withInterceptorsFromDi,
} from "@angular/common/http";
import { AuthInterceptor } from "./app/interceptors/auth.interceptors.class";

bootstrapApplication(AppComponent, {
  providers: [
    provideHttpClient(
      withInterceptorsFromDi() // Sử dụng interceptor từ DI (class AuthInterceptor)
    ),
    {
      provide: HTTP_INTERCEPTORS,
      useClass: AuthInterceptor,
      multi: true,
    }, // Sử dụng interceptor từ DI (class AuthInterceptor)
  ],
}).catch((err) => console.error(err));
```
### 4.2. Response Interceptor
- Để tạo một Response Interceptor, bạn có thể sử dụng cách tương tự như Request Interceptor thêm `pipe` và `tap`
> `tap` cho phép bạn thực hiện các hành động phụ mà không làm thay đổi luồng dữ liệu.
```ts
import { HttpEvent, HttpEventType, HttpHandler, HttpInterceptor, HttpRequest } from "@angular/common/http";
import { Observable } from "rxjs";
import { Injectable } from "@angular/core";

@Injectable()
export class AuthInterceptor implements HttpInterceptor {
  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    console.log("Auth Interceptor");
    const cloned = req.clone({
      headers: req.headers.set("Authorization", "Bearer YOUR_TOKEN"),
    });
    console.log(cloned);
    return next.handle(cloned).pipe(
      tap({
        next: (event) => {
          if (event.type === HttpEventType.Response) {
            console.log("Response Interceptor");
            console.log(event.status);
            console.log(event.body);
          }
        },
      })
    );
  }
}
```

- Các loại HttpEventType
  - HttpEventType.Response: Nhận phản hồi
  - HttpEventType.User: Sự kiện người dùng
  - HttpEventType.DownloadProgress: Tiến trình tải xuống
  - HttpEventType.UploadProgress: Tiến trình tải lên
  - HttpEventType.ResponseHeader: Nhận thông tin tiêu đề phản hồi
  - HttpEventType.Sent: Loại sự kiện đã gửi
