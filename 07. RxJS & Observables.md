# RxJS và Observables
## 1. Giới thiệu về RxJS
- **RxJS** (Reactive Extensions for JavaScript) là một thư viện cho phép lập trình viên làm việc với các luồng dữ liệu bất đồng bộ bằng cách sử dụng các observable.
- **Observable** là một đối tượng đại diện cho một luồng dữ liệu có thể được quan sát. Nó cho phép bạn lắng nghe và phản hồi với các sự kiện xảy ra theo thời gian.
- RxJS cung cấp nhiều toán tử để biến đổi, lọc và kết hợp các observable, giúp việc xử lý dữ liệu bất đồng bộ trở nên dễ dàng hơn.

Chi tiết tại: [RxJS Official Documentation](https://rxjs.dev/)

## 2. Tạo Observable
- Bạn có thể tạo một observable bằng cách sử dụng hàm `new Observable()` từ RxJS:
```typescript
import { Observable } from 'rxjs';

const myObservable = new Observable(
  subscriber => {
    subscriber.next('Hello'); // Phát ra giá trị 'Hello' của observable
    subscriber.next('World'); // Phát ra giá trị 'World' của observable
    subscriber.complete(); // Kết thúc observable
  }
);

const customInterval = new Observable((subscriber) => {
  let count = 0;
  const interval = setInterval(() => {
    if (count > 10) {
      clearInterval(interval);
      subscriber.complete();
      return;
    }
    subscriber.next(count++);
  }, 1000);
});
```

## 3. Sử dụng Observable
- Để sử dụng một observable, bạn cần đăng ký (subscribe) vào nó:
```typescript
myObservable.subscribe({
  next: value => console.log(value), // Xử lý giá trị phát ra từ observable
  complete: () => console.log('Completed'), // Xử lý khi observable hoàn thành
  error: err => console.error('Error:', err) // Xử lý khi có lỗi xảy ra
});

customInterval.subscribe({
  next: value => console.log(value),
  complete: () => console.log('Custom Interval Completed'),
  error: err => console.error('Error:', err)
});
```

## 4. Toán tử trong RxJS
- RxJS cung cấp nhiều toán tử để làm việc với observable, bao gồm:
  - **map**: Biến đổi giá trị phát ra từ observable.
  - **filter**: Lọc các giá trị phát ra từ observable.
  - **merge**: Kết hợp nhiều observable thành một.
  - **switchMap**: Chuyển đổi giá trị phát ra từ observable này sang một observable khác.

## 5. So sánh Observables và Signal trong Angular
| Tiêu chí         | Observables                          | Signal                               |
|------------------|-------------------------------------|--------------------------------------|
| Khái niệm        | Đại diện cho một luồng dữ liệu có thể được quan sát | Đại diện cho một giá trị có thể thay đổi theo thời gian |
| Cách sử dụng      | Sử dụng subscribe để lắng nghe các giá trị phát ra | Sử dụng để theo dõi và phản ứng với các thay đổi giá trị |
| Hủy đăng ký      | Cần hủy đăng ký để tránh rò rỉ bộ nhớ | Tự động hủy đăng ký khi không còn sử dụng |
| Tính bất đồng bộ  | Hỗ trợ tốt cho các tác vụ bất đồng bộ | Thích hợp cho các tác vụ đồng bộ và đơn giản |
| Giá trị          | Có thể phát ra nhiều giá trị theo thời gian | Chỉ có một giá trị duy nhất tại một thời điểm |
| Áp dụng          | Thích hợp cho các luồng dữ liệu phức tạp, nhiều sự kiện | Thích hợp cho các tình huống đơn giản, quản lý trạng thái |

## 6. Chuyển đổi giữa Observables và Signal
### 6.1. Từ Signal sang Observable
- Để chuyển đổi từ một signal sang observable, bạn có thể sử dụng hàm `toObservable` từ thư viện `@angular/core/rxjs-interop`:
```typescript
import { Component, DestroyRef, inject, OnInit, signal } from "@angular/core";
import { toObservable } from "@angular/core/rxjs-interop";

@Component({
  selector: "app-root",
  standalone: true,
  templateUrl: "./app.component.html",
})
export class AppComponent implements OnInit {
  private destroyRef = inject(DestroyRef);
  count = signal(0);
  clickCount$ = toObservable(this.count); // Chuyển đổi signal thành observable (đặt tên biến theo quy tắc có dấu $ ở cuối)
  ngOnInit(): void {
    const subscription = this.clickCount$.subscribe({
      next: (value) => {
        console.log("Current count:", value);
      },
      complete: () => console.log("Completed"),
      error: (err) => console.log("Error: ", err),
    });

    this.destroyRef.onDestroy(() => {
      subscription.unsubscribe();
    });
  }
}

```

### 6.2. Từ Observable sang Signal
- Để chuyển đổi từ một observable sang signal, bạn có thể sử dụng hàm `toSignal` từ thư viện `@angular/core/rxjs-interop`.

```typescript
import { Component } from "@angular/core";
import { toSignal } from "@angular/core/rxjs-interop";
import { interval } from "rxjs";

@Component({
  selector: "app-root",
  standalone: true,
  templateUrl: "./app.component.html",
})
export class AppComponent {
  interval$ = interval(1000); // Observable phát ra giá trị mỗi giây
  interval = toSignal(this.interval$, {
    initialValue: 0,
  }); // Chuyển đổi observable thành signal
}
```

> Lưu ý: Khi chuyển đổi từ observable sang signal, bạn cần cung cấp giá trị khởi tạo (initialValue) để signal có giá trị ban đầu (Do observable có thể không phát ra giá trị ngay lập tức). 
> Sử dụng `manualCleanup` để hủy đăng ký một cách thủ công khi không còn cần thiết.

## 7. Các loại Subject phổ biến
- **`Subject`**: Luồng nóng không có giá trị khởi tạo. Những subscriber đăng ký sau sẽ chỉ nhận giá trị mới.
- **`BehaviorSubject`**: Bắt buộc truyền giá trị mặc định và luôn phát giá trị mới nhất cho subscriber mới. Hoàn hảo để lưu trữ state hiện tại (ví dụ user profile).
- **`ReplaySubject`**: Lưu nhiều giá trị trước đó (mặc định vô hạn). Dùng khi bạn muốn "phát lại" một số sự kiện đầu vào (ví dụ log, history). Hãy giới hạn buffer để tránh tiêu tốn bộ nhớ.
- **`AsyncSubject`**: Chỉ phát giá trị cuối cùng khi observable hoàn thành. Dùng cho các tác vụ chỉ quan tâm đến kết quả cuối.

## 8. Nhóm toán tử thường dùng
| Mục đích | Toán tử | Ghi chú |
|----------|---------|---------|
| Biến đổi | `map`, `pluck`, `scan` | `scan` giống `reduce` nhưng phát giá trị mỗi lần tích lũy |
| Lọc | `filter`, `distinctUntilChanged`, `take`, `skip` | Dùng `distinctUntilChanged` cho form hoặc search box để tránh gọi API liên tục |
| Kết hợp | `mergeMap`, `switchMap`, `concatMap`, `exhaustMap` | Chọn operator dựa trên cách xử lý observable lồng nhau (switchMap hủy request cũ, concatMap xử lý nối tiếp) |
| Tiện ích | `tap`, `finalize`, `delay`, `retry`, `catchError`, `shareReplay` | `shareReplay({ bufferSize: 1, refCount: true })` giúp cache dữ liệu HTTP |
| Điều khiển thời gian | `debounceTime`, `throttleTime`, `interval`, `timer` | Hữu ích cho auto-save, search, progress bar |

## 9. Chiến lược quản lý vòng đời
- **`takeUntilDestroyed()`** (Angular 16+): đơn giản hóa việc hủy subscription trong component/service. Sử dụng thay vì tự giữ `Subject`.
```ts
this.form.valueChanges
  .pipe(takeUntilDestroyed())
  .subscribe(value => console.log(value));
```
- **`Subscription` cho logic thuần**: Nếu bạn không thể dùng `takeUntilDestroyed()`, lưu `subscription` và gọi `unsubscribe()` trong `ngOnDestroy`.
- **`firstValueFrom` / `lastValueFrom`**: Khi cần bridge Observable sang `async/await`. Tuy nhiên tránh lạm dụng vì mất lợi điểm stream; chỉ dùng trong các hàm helper hoặc khi chờ một giá trị duy nhất.

## 10. Mẫu sử dụng RxJS trong Angular
- **HTTP + tối ưu UI**: Dùng `switchMap` cho ô tìm kiếm, `concatMap` cho thao tác hàng đợi (tạo nhiều tài nguyên), `retry({ count: 3, delay: 500 })` cho request không ổn định.
- **Router events**: `this.router.events.pipe(filter(e => e instanceof NavigationStart))` cho phép bạn hiển thị loading indicator khi điều hướng.
- **Reactive Forms**: Lắng nghe `valueChanges`, kết hợp `debounceTime` và `distinctUntilChanged` để gọi API validate theo thời gian thực.
- **WebSocket**: Sử dụng `webSocket` từ `rxjs/webSocket` để làm việc với luồng dữ liệu thời gian thực. Kết hợp `share` và `retry` để tự động kết nối lại.
- **Kết hợp với Signals**: Store service có thể lắng nghe Observable và cập nhật signal, sau đó component chỉ cần đọc signal (`todos()`), tránh subscribe lặp lại trong nhiều nơi.
